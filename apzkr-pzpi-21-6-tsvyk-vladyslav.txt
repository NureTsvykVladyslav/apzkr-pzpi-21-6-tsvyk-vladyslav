Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для моніторингу та керування пасікою

Студент гр. ПЗПІ-21-6		 __________________ Цвик В.І.
(підпис)
Керівник роботи 			___________________ ст.викл. Сокорчук І.П.
(підпис) 
Роботу захищено «__»_________2024 р.
з оцінкою _________________________ 

Комісія: 				___________________ доц. Лещинський В.О. 
(підпис)
___________________ доц. Лещинська І.О. 
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)



Харків
2024 р.
Харківський національний університет радіоелектроніки 

Факультет комп’ютерних наук		 Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення				
Курс                     3                     Семестр 	                  6 				
Навчальна дисципліна Архітектура програмного забезпечення			

ЗАВДАННЯ 
НА КУРСОВУ РОБОТИ СТУДЕНТОВІ  
                                            Цвику Владиславу Івановичу				
1. Тема проекту: Програмна система моніторингу та керування пасікою	
2. Термін узгодження завдання курсової роботи «_18_»_березня_ 2024 р.
3. Термін здачі студентом закінченої роботи «  15  »   червня    2024 р.  
4. Вихідні дані до проекту: в програмній системі передбачити: додавання, редагування, видалення менеджерів, пасік, вуликів, обладнання, відстеження параметрів вулика та пасіки. Використовувати ОС Windows 11, СКБД Microsoft SQL Server, середовище розробки Microsoft Visual Studio 2022.	
5. Зміст пояснювальної записки (перелік питань, що належить розробити):
вступ, аналіз предметної області, постановка задачі, проектування бази даних, проектування та архітектура програмного проекту, опис розробленої програмної системи, висновки, перелік посилань,  додатки 			
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): 
схема бази даних, діаграма варіантів використання, діаграма розгортання, діаграма компонентів, діаграма пакетів, інтерфейси сторінок програмного продукту 											    
 
КАЛЕНДАРНИЙ ПЛАН

№	Назва етапів курсової роботи	Термін виконання
етапів	Примітка
1	Функціональна специфікація 
програмного проекту	3 квітня 
2024 року	
2	Проектування програмного 
проекту	15 квітня
2024 року	
3	Кодування програмного проекту	1 травня 
2024 року	
4	Оформлення пояснювальної 
записки	30 травня 
2024 року	
5	Захист курсової роботи	14 червня 
2024 року	

Дата видачі завдання «__18__»____ березня____2024 р.  

Керівник 				 ______________  ст.викл. Сокорчук І.П.
(підпис)  
Завдання прийняв до виконання 
ст.гр. ПЗПІ-21-6			 _____________		 Цвик В.І. 
         (підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсового проектування: 93 с., 30 рис., 1 табл., 5 джерел, 4 додатки.
АРХІТЕКТУРА ПРОГРАМИ, БДЖІЛЬНИЦТВО, БДЖОЛИ, ІНТЕРНЕТ РЕЧЕЙ, КЛІЄНТ, МОВА ПРОГРАМУВАННЯ С#, ОБ’ЄКТНО-ОРІЄНТОВАНЕ ПРОГРАМУВАННЯ, ПАСІКА, РОЗУМНА ПАСІКА, ANGULAR, ESP32, HX711б SMART HIVE, VISUAL STUDIO, DHT22
Метою роботи є розробка інформаційної системи для підтримки роботи пасіки, яка автоматизує процеси моніторингу та управління умовами у вуликах за допомогою технологій Інтернету речей (IoT). Система забезпечує збирання даних з сенсорів, їх аналіз та обробку, а також своєчасне сповіщення бджолярів про критичні показники.
Поставлена задача вирішується шляхом проектування та кодування програмного продукту за обраною предметною областю. Під час розробки використовуються різні технології та засоби розробки, такі як .NET, ASP.NET, SQL Server для серверної частини, Angular для клієнтської частини, C++ для розумних пристроїв, Xamarin для мобільного додатку.
В результаті курсового проектування було розроблено програмний продукт для моніторингу та керування пасікою "ApexiBee Smart Hive", який може використовуватися у сфері бджільництва для автоматизації процесів управління пасікою. Система забезпечує підвищення ефективності управління пасікою, зниження трудових витрат та покращення якості продукції.





ЗМІСТ



ВСТУП	7
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1 Загальний огляд	9
1.2 Аналіз існуючих аналогів	10
1.3 Потреби потенційних користувачів	12
2 ПОСТАНОВКА ЗАВДАННЯ	14
2.1 Бачення програмної системи	14
2.2 Основні функції системи	15
2.3 Обсяг початкового випуску	16
3 АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ СИСТЕМИ	22
3.1 Опис загальної архітектури системи	22
3.2 Архітектура серверної частини	23
3.3 Архітектура клієнтської частини	25
3.4 Архітектура програмного забезпечення для розумних пристроїв	28
3.5 Архітектура мобільного застосунку	31
3.6 Структура бази даних	34
4 РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ	36
4.1 Реалізація серверної частини	36
4.2 Реалізація клієнтської частини	39
4.3 Реалізація програмного забезпечення для розумних пристроїв	41
4.4 Реалізація мобільного застосунку	42
 
5 ОПИС СТВОРЕНОЇ СИСТЕМИ	44
5.1 Опис серверної частини	44
          5.2 Опис клієнтської частини	44
5.3 Опис взаємодії з розумними пристроями	56
5.4 Опис взаємодії з мобільним застосунком	60
ВИСНОВКИ	65
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	66
ДОДАТОК А	67
ДОДАТОК Б	73
ДОДАТОК В	83
ДОДАТОК Г	90


 
ВСТУП

У сучасному світі, де аграрний сектор відіграє критичну роль у забезпеченні продовольчої безпеки, ефективне управління пасіками стає дедалі важливішим завданням. Бджільництво є однією з ключових складових аграрної економіки, оскільки бджоли виконують надзвичайно важливу роль у запиленні сільськогосподарських культур, що безпосередньо впливає на врожайність і якість продукції. Однак, сучасні пасіки стикаються з численними викликами, такими як зміни клімату, хвороби бджіл, недостатнє моніторинг і управління умовами всередині вуликів.
Розробка програмної системи для моніторингу та керування пасікою спрямована на вирішення цих проблем за допомогою передових технологій Інтернету речей (IoT). Система інтегрує різноманітні датчики для моніторингу температури, вологості, активності бджіл та ваги меду в реальному часі. Завдяки використанню таких датчиків, бджолярі отримують можливість своєчасно реагувати на зміни в умовах вуликів і вживати необхідних заходів для підтримання оптимальних умов для бджіл, а також прогнозувати можливий врожай меду.
Актуальність цієї теми обумовлена необхідністю підвищення ефективності та стійкості пасік. Традиційні методи управління пасіками часто вимагають значних зусиль і часу. Впровадження автоматизованої системи моніторингу дозволяє значно знизити трудовитрати. Це особливо важливо в умовах сучасних екологічних викликів та підвищених вимог до якості продукції.
Крім того, використання IoT-технологій у бджільництві відкриває нові можливості для збирання та аналізу даних, що може сприяти науковим дослідженням і переосмисленню бджільництва загалом. Збір великої кількості даних про стан вуликів та поведінку бджіл дозволяє виявляти закономірності та передбачати потенційні проблеми, що є важливим кроком до створення більш стійких та продуктивних пасік.
У цьому контексті розробка системи для керування та моніторингу пасіки є надзвичайно актуальною і перспективною, оскільки вона пропонує інноваційний підхід до управління пасіками, використовуючи сучасні технології для забезпечення ефективного і екологічно безпечного виробництва меду.
Метою даної роботи є створення подібної системи для бджолярів, яка б дозволила автоматизувати процеси на пасіці. Система повинна складатися з декількох взаємопов’язаних між собою компонентів (серверна частина, клієнтська частина, розумні пристрої та застосунок для мобільних девайсів). Під час розробки необхідно дотримуватися принципів побудови масштабованої архітектури. 
Для поставленої задачі необхідно проаналізувати предметну область і потреби потенційних користувачів, розробити архітектуру програмної системи та її окремих компонентів, програмно реалізувати та протестувати усі частини системи.
 
1	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Загальний огляд


Останніми роками сільське господарство переживає справжню революцію завдяки впровадженню технологій Інтернету речей (IoT) та інтелектуального аналізу даних. Однак, незважаючи на значні успіхи в більшості сегментів, бджільництво залишається відносно незачепленим сучасними технологіями, хоча і має величезний потенціал для інновацій.
Традиційно, управління пасікою охоплює безліч трудомістких процесів, таких як контроль за здоров'ям бджіл, оптимізація умов для розведення та збору меду, а також моніторинг довкілля та умов всередині вулика. Ці завдання вимагають постійної уваги та часу від бджоляра, що робить процес не тільки складним, а й часто неефективним у плані розподілу ресурсів.
Також існує проблема логістики і управління декількома пасіками з великою кількістю вуликів. Бджолярі стикаються стикаються з проблемою збору та аналізу даних про стан кожного окремого вулика.
Розвиток технології "розумних" вуликів з інтегрованими датчиками надає можливість радикально трансформувати цей традиційний підхід. Використовуючи дані з датчиків, бджолярі можуть отримувати реальну картину стану кожного вулика в режимі онлайн, що дає змогу вчасно реагувати на зміни та запобігати можливим проблемам, покращуючи продуктивність і зменшуючи втрати.
Існуючі системи управління пасікою часто стикаються з обмеженнями, які не дозволяють повністю вирішувати вищеописані проблеми. Наприклад, більшість систем не надають можливості моніторингу в реальному часі, що ускладнює своєчасне реагування на зміни у вуликах і навколишньому середовищі. Також, вони не завжди надають можливість створення повноцінної розумної пасіка, яка б об’єднувала в собі багато зв’язних компонентів, а не являли собою окремі вулики. До того ж такі системи зазвичай не мають функції автоматизації повсякденних завдань, що залишає бджолярам необхідність виконувати багато операцій вручну, збільшуючи трудовитрати і ризик помилок.
Наразі існує значний попит на інтегровану систему управління пасікою, яка могла б автоматизувати багато рутинних процесів і підвищити ефективність роботи бджолярів.


1.2	Аналіз існуючих аналогів


Бджільництво в Україні - галузь, що активно розвивається, має тривалу історію та значний вплив на економіку країни. Україна посідає одне з лідируючих місць у світі за кількістю пасік і виробництвом меду, що створює сприятливі умови для впровадження інноваційних рішень у цьому секторі. Однак попит на продукти бджільництва є не тільки в Україна, а й в усьому світі, тому інновації у цій галузі потрібні й за межами країни, а розвиток розумних ферм лише спряє переходу бджолярів на автоматизовані пасіки.
Наразі на ринку існує не так багато рішень для створення розумної пасіки, а існуючі рішення мають обмеження в аналізі даних, інтерфейсі користувача, доступних функціях та масштабованості, що істотно знижує їхню ефективність у вирішенні існуючих проблем бджільництва. Одним з таких рішень є iBee. Це система керування пасікою, яка пропонує автоматизацію процесів і моніторинг стану вуликів. Однак ця система має певні недоліки: даний продукт являє собою лише мобільний застосунок без повноцінної версії для веб-браузерів. Сам програмний продукт надає обмежений функціонал для відстеження показників вулика (статистика надається лише за тиждень без можливості масштабування графіків), а алгоритми для підрахунку ваги вулика є недосконалими. 
Другим популярним рішенням для розумної пасіки є система Yylei. Даний продукт надає аналогічну пропозицію для створення розумної пасіки. Ця система також має свої недоліки: інтерфейс мобільного застосунку морально застарілий, а серед представлених показників для моніторингу є лише вага та температура. Також у застосунку відсутні інструменти для детального аналізу системи протягом тривалого часу, а також можливість групувати вулики у окремі пасіки. 
Наша система пропонує користувачам комплексне рішення, яке складатиметься з декількох компонентів, а не окремих непов’язаних між собою вуликів, таких як хаб та власне вулики, які будуть до нього під’єднані. Мобільний застосунок, на відміну від конкурентів, буде надавали можливість аналізувати усі показники з датчиків, таких як вологість, вага вулику, спектр шуму, рухливість бджіл за довгий проміжок часу, а також відповідатиме сучасним стандартам безпеки. Окрім цього, наш програмний продукт буде здійснювати аналіз отриманих даних про стан вулику на основі штучного інтелекту і надавати бджолярам відповідні рекомендації.
Монетизація продукту буде здійснюватися декількома шляхами. По-перше, передбачається отримання доходу від продажу обладнання для розумної пасіки (хаби та вулики з датчиками). Додатковим джерелом доходу є підписка на користування усіма функціями мобільного застосунку для моніторингу вуликів. Безкоштовна версія надаватиме обмежений функціонал, у той час підписка надаватиме просунуті аналітичні інструменти з підтримкою штучного інтелекту, який надаватиме поради бджолярам на основі поточних даних про вулики.


 
1.3	Потреби потенційних користувачів


Основними клієнтами нашої системи є бджолярі, які є власниками малих пасік, а також власники середніх і великих аграрних компаній, які займаються бджільництвом. Також нашою системою може користуватися попитом серед дослідницьких інститутів, які займаються вивченням бджіл і зацікавлені в зборі точних наукових даних про поведінку бджіл та впливу на них зовнішніх умов.
 
Основні потреби власників пасік та фермерських підприємств:
- моніторинг стану вуликів у реальному часі (відсутність можливості надання точної та оперативної інформації про стан вуликів є великою проблемою для бджолярів, вони потребують системи, яка б дозволяла відстежувати основні параметри, такі як температура, вологість, активність бджіл та вага вулика);
- автоматизація рутинних процесів (бджолярі часто витрачають багато часу на виконання повсякденних задач, таких як підкормка бджіл або обробка вуликів від шкідників, існуючі системи рідко надають ефективні рішення для автоматизації цих процесів);
- інтеграція з існуючим обладнанням (деякі бджолярі вже використовують різноманітне обладнання та програмне забезпечення у процесі роботи з пасіками, тому важливо, щоб нова система могла легко інтегруватися з існуючими рішеннями без необхідності значних інвестицій у заміну обладнання);
- здатність адаптації до різних кліматичних умов (бджільництво проводиться в різноманітних кліматичних умовах, і система повинна бути достатньо гнучкою, щоб адаптуватися до цих умов, забезпечуючи надійність та точність роботи обладнання).
Основні потреби дослідницьких центрів:
- забезпечення даних для наукових досліджень (дослідницькі інститути потребують високоточні дані для аналізу, і їм необхідна система, здатна забезпечити точний збір даних та їх аналіз в різних умовах);
- надійність та доступність системи (система повинна бути доступною для користування 24/7);
- модульність та адаптивність (система повинна мати можливість налаштування під специфічні експериментальні умови).



2	ПОСТАНОВКА ЗАВДАННЯ
2.1	Бачення програмної системи


Створена програмна система повинна являти собою інноваційну систему для інтегрованого управління пасіками, яка застосовує передові технології IoT (датчики стану оточуючого середовища, датчики для контролю за активністю бджіл, датчики для вимірювання ваги вулику) для збору даних та автоматизації процесів, підвищуючи продуктивність та знижуючи витрати роботи бджолярів. Продукт розробляється з урахуванням потреб малих, середніх та великих пасік, а також наукових дослідницьких інститутів, що дозволяє забезпечити широкий спектр застосування.
Система включатиме в себе сучасне обладнання для моніторингу основних параметрів вуликів, таких як температура, вологість і активність бджіл, а також інструменти для аналізу зібраних даних. Це дозволить оперативно реагувати на зміни та оптимізувати умови утримання бджіл. Автоматизація повсякденних задач, таких як підкормка бджіл та обробка від шкідників, значно зменшить фізичні зусилля бджолярів та підвищить загальну ефективність пасіки.
Реалізація цієї системи не тільки змінить підхід до бджільництва, перетворивши традиційні методи на сучасні технологічні процеси, але й відкриє нові можливості для наукових досліджень та розвитку галузі. Завдяки точному моніторингу та аналізу даних, бджолярі зможуть не тільки підвищити урожайність меду, але й забезпечити краще здоров'я бджіл.
Ця система стане незамінним інструментом в руках бджолярів та науковців, сприяючи більш сталому та продуктивному бджільництву. Це відкриє нові перспективи для розвитку цієї галузі, зберігаючи природні ресурси та покращуючи якість продукції.


2.2	Основні функції системи


Відповідно до основних потреб потенційних користувачів можна виділити наступні основні функції, що мають бути присутні у системі:
- реєстрація, можливість створення аккаунтів різних типів (для малих пасік та великих підприємств);
	- групування вуликів у пасіки за допомогою хабів;
	- автоматична інтеграція розумного обладнання до системи після замовлення бджолярами;
	- можливість вручну додати обладнання до аккаунту за допомогою серійного номера чи QR-коду;
	- моніторинг таких показників, як температура та вологість за допомогою датчиків у реальному часі;
	- аналіз активності бджіл (кількість бджіл в вулику, їхнє переміщення з вулика та всередину);
	- відстеження ваги вулика для аналізу кількості меду в сотах за допомогою датчиків та штучного інтелекту;
	- візуалізація зміни параметрів, які збираються датчиками у вигляді графіків з можливістю вибору періоду відображення даних (буде доступна статистика, яка збирається протягом року);
	- можливість інтеграції системи з уже існуючим обладнанням на пасіці без необхідності значних модифікацій;
	- рекомендації бджолярам у застосунку за результатами аналізу поточних даних з вуликів і пасік;
	- аналітика та звіти, можливість формувати звіти за пасіками та вуликами з різними даними (їх кількість, продуктивність меду);
	- повідомлення бджолярам у випадку досягнення критичного значення датчиків (температура, вологість тощо);
	- облік клієнтів, які придбали обладнання для розумної пасіки.
2.3	Обсяг початкового випуску


На момент першого випуску продукту, система управління пасікою підтримуватиме весь функціонал, пов'язаний з моніторингом та управлінням вуликами, обліком обладнання пасіки та функціоналом для підтримки бджолярів, які користуються розумною пасікою. Пасічники зможуть приєднатися до системи, щоб використовувати всі функції, водночас із цим клієнти пасік зможуть користуватися перевагами платформи, відстежуючи стан вуликів і продуктивність бджіл. Система підтримуватиме українську та англійську мови як у веб-додатку, так і в мобільному додатку. У системі будуть підтримуватися переведення одиниць вимірювання температури, ваги, відстані та інших показників у різні системи числення для забезпечення інтернаціоналізації.
Мобільний додаток насамперед призначений для бджолярів, які керують щоденними операціями на пасіці та використовують для цього розумні пристрої. Він містить функціонал, пов'язаний з моніторингом стану вуликів, нагадуваннями про необхідні процедури догляду за бджолами та підключенням смарт-пристроїв (датчики у вуликах, автоматичні годівниці тощо) для ефективного управління.
Усі паролі в базі даних на сервері зберігатимуться в зашифрованому вигляді, а клієнт-серверна взаємодія відбуватиметься через захищені протоколи. Адміністратори системи матимуть змогу робити резервне копіювання всіх даних, пов'язаних із роботою пасіки, і за потреби відновлювати ці дані.
Окреслення функціоналу серверної частини:
- отримання та обробка запитів на отримання даних від клієнта;
- взаємодія з розумними пристроями, а саме отримання даних з хабів, пасік про поточні параметри вуликів та збереження їх у базі даних;
- шифрування даних важливих даних, таких як паролі та інформація про користувачів;
- обробка даних реєстрації та аутентифікації користувачів;
- ведення обліку усього обладнання для розумної пасіки, яке було придбано бджолярами;
- можливість оформлення замовлення на придбання обладнання для розумної ферми (хаби, вулики, датчики);
- збір та аналіз даних з вуликів, що включає моніторинг температури, вологості, ваги вуликів, та інших параметрів;
- обробка звітів про здоров'я бджіл та продуктивність вуликів;
- можливість для бджолярів додавати та редагувати інформацію про вулики та обладнання, керувати налаштуваннями системи;
- забезпечення можливості створення бекапів всіх даних системи, включно з інформацією про вулики, обладнання, та користувачів для забезпечення відновлення у випадку втрати даних.
Окреслення функціоналу клієнтської частини:
- реєстрація та авторизація пасічників, адміністраторів та менеджерів;
- перегляд інформації бджолярами про кожен вулик, включно з температурою, вологістю, вагою та активністю бджіл;
- моніторинг та аналіз даних у реальному часі, відстеження поточних показників своїх вуликів, отримання аналітичних звітів про стан і продуктивність пасіки.
- візуалізація даних за допомогою графіків та діаграм, що відображають зміни параметрів вуликів в обраному часовому інтервалі, що допомагає в аналізі тенденцій і прийнятті рішень;
- додавання, конфігурування або видалення розумного обладнання, такого як датчики та автоматизовані системи догляду за вуликами;
- підтримка української та англійської мови з можливістю її зміни;
- функціонал для менеджерів, що включатиме облік бджолярів, які придбали обладнання та можливість оформлення замовлень на їх придбання.
	- адміністрування бази даних, створення резервних копій, відновлення бази даних за потреби.
Окреслення функціоналу мобільного застосунку:
	- перегляд і редагування особистої інформації пасічника;
- моніторинг стану вуликів у реальному часі, можливість переглядати поточні дані щодо кожного вулика, включно з температурою, вологістю, вагою та активністю бджіл;
- нагадування про необхідні процедури догляду за вуликами;
- підключення та управління розумними пристроями;
-  перегляд графіків та аналітики щодо стану вуликів;
- миттєві повідомлення про критичні зміни (сповіщення) у разі виявлення аномалій або критичних змін в умовах вуликів;
- підтримка української та англійської мови у застосунку;
- можливість додавати записи до щоденнику бджоляра щодо проведених робіт та взаємодії з вуликами та пасікою по датах з можливістю подальшого перегляду внесених даних.
Окреслення функціоналу розумних пристроїв:
- передача даних з датчиків температури, вологості повітря, ваги до хабу, який агрегує інформацію з усіх вуликів пасіки; 
- автоматичне керування умовами всередині вуликів, наприклад, активуючи системи вентиляції або обігріву залежно від зібраних даних і заздалегідь заданих налаштувань; 
- інтеграція з мобільним додатком і веб-інтерфейсом, передача даних на сервер;
- можливість використання альтернативних джерел енергії, наприклад сонячних панелей, для роботи у віддалених або автономних умовах, однак основним джерелом живлення передбачається звичайні батареї. 
- забезпечення безпеки передачі даних між вуликами та хабом, та між хабом та сервером шляхом шифрування.

2.4	Обсяг наступних випусків 


У майбутніх випусках системи управління пасікою планується значне розширення функціоналу, що дозволить більш ефективно використовувати зібрані дані. Планується інтеграція штучного інтелекту у системи для аналізу даних, таких як прогнозування кількості отриманого меду та надання рекомендацій бджолярам на основі зібраних даних з датчиків. Також можливо розширення персоналізації системи. Наприклад, можливість налаштування для автоматичної адаптації системи до змін клімату. Однією з напрямків розвитку може стати розширення взаємодії між користувачами, шляхом розробки форуму, чатів, де пасічники зможуть ділитися досвідом та отримувати консультації від колег. 


2.5	Обмеження та винятки 


У поточному випуску система підтримуватиме лише розумні пристрої, які розроблені спеціально для цієї платформи. Інтеграція з розумними пристроями інших виробників не буде реалізована, щоб забезпечити стабільність та надійність роботи системи. Також не планується розробка Desktop застосунку. Деякі процеси, які потребують особистого втручання пасічника, такі як вибірковий збір меду з певних вуликів, не будуть повністю автоматизовані. У застосунку не планується підтримка інших мовних пакетів, окрім української та англійської мови. 




2.6	Робоче середовище 


Система управління пасікою розробляється для використання у різноманітних географічних умовах, що охоплюють різні кліматичні зони та культурні особливості. Можливе використання системи на усіх континентах, проте на момент випуску програма підтримує локалізацію англійською та українською мовами. Система буде використовуватися користувачами, розташованими у широкому географічному діапазоні, включаючи різні часові пояси. Всі дані, згенеровані системою, будуть зберігатися в централізованих дата-центрах з високим рівнем доступності та захисту. Попри можливі затримки у відгуках через віддалене зберігання даних, система має забезпечувати високу продуктивність обробки запитів користувачів.
Надійність системи критично важлива, оскільки перерви в доступі до даних можуть негативно вплинути на управління пасікою. Система повинна забезпечувати безперервний доступ для користувачів, з можливістю планування обслуговування системи у часи найменшої активності користувачів у кожному часовому поясі.
Вимоги до безпеки включають використання сучасних методів шифрування для зберігання і передачі даних, а також розробку надійних методів аутентифікації та авторизації користувачів. Це критично для захисту чутливої інформації про стан вуликів і особистих даних користувачів.
Веб-застосунок буде створюватися з використанням технологій Angular, HTML, CSS, JS, TS для клієнтської браузерної частини, ASP.NET Core для WebAPI серверної частини. У якості СУБД буде використовуватися MS SQL Server. Клієнтська частина для Android буде створена з використанням мови платформи Xamarin, яка є частиною екосистеми .NET і використовується для створення застосунків для мобільних пристроїв з можливістю запуску на різних операційних системах (IOS, Android). Для розробки розумних пристроїв буде використано мікроконтролер ESP-32 з інтеграцією Wi-Fi та Bluetooth, що є важливим через необхідність постійного зв’язку між хабами, вуликами та сервером. Для зв’язку між вуликами та хабом можливе використання протоколу LoRa.
 
3	АРХІТЕКТУРА ТА ПРОЄКТУВАННЯ СИСТЕМИ
3.1	Опис загальної архітектури системи


Програмна система складається з кількох основних компонентів, які взаємодіють між собою для забезпечення автоматизованого моніторингу та управління умовами вуликів. 
Центральний сервер є головним компонентом, що забезпечує обробку, зберігання та аналіз даних, отриманих з вуликів через хаби. Сервер збирає дані, зберігає їх у базі даних, аналізує для виявлення критичних показників та приймає рішення щодо необхідних дій. Сервер також забезпечує управління конфігураціями всіх пристроїв системи та відповідає за обробку усіх інших даних, отриманих від адміністраторів, менеджерів та бджолярів. Серверна частина надає усім клієнтам інтерфейс у вигляді REST API для взаємодії, відправки та отримання даних по протоколу HTTP (HTTPS).
У системі присутні два види розумних пристроїв: хаби та вулики. Хаби виконують функцію проміжних пристроїв, що агрегують дані з вуликів і передають їх на сервер. Вулики, що оснащені різноманітними сенсорами для вимірювання температури, вологості, активності бджіл та ваги меду, збирають дані та передають їх на хаби. Хаби забезпечують передачу агрегованих даних на сервер через інтернет за допомогою протоколів TCP/IP або MQTT.
Клієнтські додатки, включаючи веб-застосунок та мобільний додаток, забезпечують зручний доступ до даних системи для користувачів. Через клієнтські додатки користувачі.
Представлення взаємодії усіх компонентів, з яких скаладається система, наведена на діаграмі розгортання (рисунок 3.1).

 
Рисунок 3.1 – Діаграма розгортання програмної системи для моніторингу та керування пасікою ApexiBee


3.2	Архітектура серверної частини


Серверна частина системи представлена ASP.NET Core Web API-застосунком та написана з використанням мови програмування С# та платформи .NET 6.
Архітектура серверної частини побудована за принципами чистої Onion-архітектури, яка складається з декількох шарів: Core (Domain та Application), Infrastructure, Persistance, API.
Особливістю побудови такої архітектури є те, що залежності можуть бути присутніми тільки до внутрнішніх шарів. Таким чином Core не має залежностей від інших шарів і може існувати незалежно від фреймворків, баз даних та шару представлення у вигляді API.
Детальний опис присутніх шарів наведено нижче.
ApexiBee.API – шар, що представляє собою точку входу для HTTP-запитів та відповідає за маршрутизацію, автентифікацію, авторизацію та обробку запитів за допомогою контролерів. Всі HTTP-запити від клієнтів обробляються на цьому рівні, де здійснюється початкова обробка та передача запитів до рівнів бізнес-логіки.
ApexiBee.Application -  шар містить бізнес-логіку системи та оркеструє виконання запитів, обробляючи їх через відповідні сервіси. Використання цього шару дозволяє ізолювати бізнес-логіку від деталей реалізації інфраструктури, що спрощує тестування та модифікацію коду.
У шарі ApexiBee.Domain визначаються основні об'єкти доменної моделі та логіка, пов'язана безпосередньо з ними. Сюди відносяться класи сутностей, їх властивості та методи, які відповідають за поведінку об'єктів у системі. Даний шар не залежить від інших рівнів і може використовуватись в інших застосунках.
Шар ApexiBee.Infrastructure.Interfaces містить інтерфейси для взаємодії з інфраструктурними компонентами, такими як бази даних, файлові системи, зовнішні сервіси та інші. Інтерфейси визначають контракти для реалізацій, які містяться у шарі ApexiBee.Infrastructure.Implementations.
ApexiBee.Infrastructure.Implementations: - шар, що містить реалізації інтерфейсів, визначених у шарі ApexiBee.Infrastructure.Interfaces. Тут здійснюється конкретна реалізація взаємодії з зовнішніми сервісами та іншими інфраструктурними компонентами. Це забезпечує гнучкість та можливість легко замінювати конкретні реалізації без зміни коду інших рівнів.
Шар ApexiBee.Persistance відповідає за роботу з базою даних за допомогою ORM Entity Framework Core. Він містить реалізації репозиторіїв, налаштування контексту бази даних та методи для виконання транзакцій. Використання цього шару дозволяє централізувати роботу з даними та спрощує підтримку і тестування.
У цій архітектурі забезпечується чітке розділення відповідальності між різними частинами системи, що дозволяє легко підтримувати, тестувати та розширювати систему. Кожен шар взаємодіє з іншими через чітко визначені інтерфейси, що забезпечує слабку зв'язність і високу модульність системи.
У серверному застосунку використано такі патерни та принципи, як Dependency Injection, Unit of work, Bridge.
Пакетну структуру серверної частини наведено на рисунку 3.2.

 
Рисунок 3.2 – Діаграма пакетів серверної частини програмного продукту


3.3	Архітектура клієнтської частини


Для створення клієнтської частини використовується платформа Angular, що створена з використанням мови TypeScript, який у свою чергу є розширенням для JavaScript. Angular дозволяє створювати масштабовані проекти, які складаються з багатьох модулів і компонентів. При створенні системи використовуються деякі стандартні елементи керування та відображення з бібліотеки primeng, яка містить велику кількість різних елементів для створення користувацьких інтерфейсів. Для задання стилів використовується розширення для таблиць каскадних стилів SCSS.
Код Angular застосунку розділено на модулі та компоненти, відповідно до завдань, які виконуються цими частинами програми.
В основі усього застосунку знаходиться головний модуль – Application module, до якого приєднуються усі інші модулі. За доступ користувачів до певних endpoints відповідає модуль маршрутизації (Router module). Він визначає, які модулі та компоненти треба завантажувати при запиті певної кінцевої точки користувачем.
Уся бізнес-логіка розділена між різними модулями (Apiary module, Profile module, Order module, Admin module, Settings module, Auth module, Equipment module, Home module), відповідно до частини функціоналу, за яку відповідає цей модуль. Admin module містить усю логіку та компоненти для роботи адміністратора. Orders module відповідає за усі замовлення клієнтів. Auth module містить усі компоненти для авторизації. Profile module відповідає за сторінку профілю користувача. Home module - це початкові сторінки з основною інформацією. Apiary module - модуль для роботи з пасіками та вуликами. Equipment module відповідає за роботи з обладнанням та серійними номерами. Взаємодію між модулями та компонентами клієнтської частини наведено на діаграмі пакетів (рисунок 3.3).

 
Рисунок 3.3 – Діаграма пакетів клієнтської частини

Клієнтський веб-застосунок повинен взаємодіяти з серверною частиною. Angular передбачає створення веб-застосунків, які складаються з однієї HTML-сторінки з вбудованою маршрутизацію, яка дозволяє завантажувати потрібні ресурси по мірі необхідності і відображати їх кінцевому користувачу. Взаємодію логічних компонентів клієнтської частини, з яких складається застосунок, між собою та з зовнішніми інтерфейсами наведено на діаграмі компонентів (рисунок 3.4).

 
Рисунок 3.4 – Діаграма компонентів для візуалізації взаємодії клієнтської частини та зовнішніх систем


3.4	Архітектура програмного забезпечення для розумних пристроїв


Для повноцінного функціонування програмної системи для моніторингу та керування пасікою "ApexiBee" необхідна інтеграція розумних пристроїв.
У системі представлені два пристрої: центральний вузол пасіки (hub) та вулик (hive). Вони взаємопов'язані один з одним та сервером та дотримуються концепції Internet of Things.
Для реалізації функціоналу розумних пристроїв використовується мікроконтролер ESP32, датчик DHT22 для вимірювання температури та вологості повітря, датчик навантаження HX711 для вимірювання ваги, модуль micro SD карти та деякі інші елементи. Для програмної реалізації була використана мова програмування C++, а також середовище Wokwi для імітації роботи та взаємодії розумних пристроїв. Додатково використовувалися бібліотеки для роботи з апаратною частиною та веб-взаємодією, такі як SD.h, HX711.h, WiFi.h, DHTesp.h, ArduinoJson.h, HTTPClient.h. 
Основний функціонал містить в собі розумний пристрій “Hive”, який відповідає за отримання даних з датчиків. Мікроконтролер ESP32 містить вбудовані модулі WiFi та Bluetooth, що спрощує його взаємодією з іншими елементами системи. До мікроконтролера вулика під'єднано два датчики (DHT22 та HX711) для вимірювання вологості, температури та ваги вулика. За потреби можна під'єднати інші датчики до інших пінів та розширити функціонал. Також до нього під'єднано інтерфейс для підключення micro SD карти, де зберігається конфігурація, а також, за потреби, дані з датчиків за певний проміжок часу. Додатково для взаємодії з пристроєм до нього підключено дві кнопки (для калібровки ваг та конфігурації), а також LED індикатор.
Ще один пристрій у системі - це “Hub”. Він отримує дані з вуликів, групує їх та з певною періодичністю (раз на пів години) відправляє усі дані, отримані з усіх вуликів пасіки, на сервер. Додатково цей пристрій отримує дані про критичні значення даних для датчиків з серверу та взаємодіє з пристроями “Hive” для нормалізації значень температури та вологості у вуликах.
Для відображення взаємодії між компонентами, модулями та зовнішніми бібліотеками програмного забезпечення для розумних пристроїв побудовано діаграму пакетів (рисунок 3.5).



 
Рисунок 3.5 – Діаграма пакетів для візуалізації модулів, з яких 
складається підсистема розумного пристрою

Основний пакет - ApexiBee Smart Hive Device. Він інтегрує конфігураційну структуру (Config Structure), сервіс агрегованих даних з сенсорів (Aggregated Sensor Data Service), менеджер конфігурацій (Config Manager), утиліту часу (Time Util) та сервіс відправки даних сенсорів (Sensor Send Service). Він використовує бібліотеку для роботи з SD-картами (SD card library), бібліотеку для сенсора HX711 (HX711 sensor library), бібліотеку сенсорів DHT для ESPx (DHT sensor lib for ESPx) та бібліотеку ArduinoJson.
Config Structure забезпечує структуру конфігураційних даних. Aggregated Sensor Data Service надає послуги з агрегування даних сенсорів Config Manager керує конфігураціями системи. Time Util надає утиліти для роботи з часом. Sensor Send Service забезпечує функціонал відправки даних сенсорів на сервер. SD card library використовується  для роботи з SD-картами. HX711 sensor library використовується  для інтеграції з сенсором ваги HX711. DHT sensor lib for ESPx використовується для інтеграції з сенсорами DHT22. ArduinoJson використовується для роботи з форматом JSON.
3.5	Архітектура мобільного застосунку


Для створення мобільного застосунку використовується платформа Xamarin, яка працює під управлінням .NET і націлена на створення крос-платформних застосунків під управлінням Android, IOS чи Windows 10/11. 
Xamarin дозволяє створювати один код для усіх платформ, що значно прискорює розробку застосунку, а мова C#, яка використовується при розробці є досить продуктивною. 
Для розмітки сторінок використовується мова XAML, яка дозволяє створювати гнучкі графічні інтерфейси.
Програмний мобільний застосунок взаємодіє з серверною частиною по протоколу HTTP.
Для побудови архітектури застосунку застосовується патерн проектування MVVM. Він складається з 3 основних частин – Model, View та ViewModel. Використання цього патерну дозволяє розділити логіку роботи з даними їх відображення та дизайн застосунку у різні компоненти, що робить програмий код більш гнучким.
В основі усього застосунку знаходиться головний модуль – Application, до якого приєднуються усі інші модулі, такі як відображення (Views), відображення моделі (ViewModels), статичні ресурси (Resources), об’єкти для передачі даних (DTO), розширення (Extentions), сервіси (Services), а також зовнішні бібліотеки (Xamarin.Essentials, System.Json, System.IdentityModel).
Користувач взаємодіє з застосунком через View, до якого прив’язуються дані з ViewModel за допомогою механізму Binding, який надає платформа та мова XAML. ViewModel взаємодіє з моделлю і отримує з неї дані. Таким чином програмна система не містить контролерів, на відміну від типових застосунків, побудованих за патерном MVC.
Додатково у застосунку визначено певні сервіси, які надають інтерфейс для моделей та відображень для взаємодії з серверною частиною, налаштуванням локалізації та інтернаціоналізації.
Програма система включає декілька пакетів. CynologistPlus Mobile Application - центральний компонент, до якого прямо чи опосередковано пов'язані всі інші компоненти. ViewModels - містить логіку представлення даних, яка використовується в користувацькому інтерфейсі додатка. Views - включає елементи користувацького інтерфейсу, які відображають дані з моделей представлення. Models - містить основні дані та бізнес-логіку додатка. DTO (Data Transfer Objects) - використовується для передачі даних між шарами додатка, зокрема між клієнтом та сервером. Resources - включає ресурси, такі як рядки, зображення та інші асети, які використовуються в додатку. Extensions - надає додаткові методи або функції, які розширюють стандартний функціонал. Services - містить сервіси, які надають певні функції або дані додатку. Xamarin.Essentials - пакет, який надає кросплатформні API для доступу до основних функцій мобільного пристрою. System.Json.Serialization - використовується для серіалізації та десеріалізації даних JSON. System.IdentityModel.Token.Jwt - пакет, який використовується для роботи з JWT-токенами для аутентифікації та авторизації.
На діаграмі пакетів представлена структура компонентів мобільного додатку (рисунок 3.6).

 
Рисунок 3.6 – Діаграма пакетів для відображення модулів, з яких складається мобільний застосунок

	Для деталізації взаємодії між компонентами мобільного застосунку була створена діаграма компонентів (рисунок 3.7).

 
Рисунок 3.7 – Діаграма компонентів мобільного застосунку
3.6	Структура бази даних


У якості моделі зберігання даних була обрана реляційна модель. Структура даних складається з 13 таблиць: користувач, роль користувача, роль, замовлення, статус замовлення, аккаунт користувача, пасіка, вулик, хаб, датчик, тип датчику, зчитування датчику, серійні дані. Для відображення моделі даних розроблена ER-модель, що побудована з використанням нотації Crow’s Foot. Вона наведена у додатку А.
У системі присутні наступні зв’язки між сутностями:
- роль та користувач мають зв'язок багато-до-багатьох через таблицю зв'язку роль користувача, яка зберігає інформацію про ролі, призначені користувачам;
- замовлення пов'язане з користувачем двома зв’язками один до багатьох, один з яких прив’язує до замовлення менеджера, який оформлював цей заказ, а інший – користувача, на якого оформлене це замовлення;
- статус замовлення пов'язаний із замовлення зв’язком один до багатьох (один статус може бути у багатьох замовлень);
- користувач пов'язаний з пасікою зв’язком один до багатьох (один користувач може керувати багатьма пасіками);
- пасіка пов’язана з вуликом зв’язком один до багатьох (на одній пасіці може знаходитись багато вуликів, проте кожен вулик належить одній пасіці);
- вулик також пов'язаний з серійним номером зв’язком один до одного (один серійний номер відповідає одному пристрою вулика);
- хаб також пов’язаний з серійним номером зв’язком один до одного (один серійний номер відповідає одному пристрою хаба);
- тип датчика пов'язаний з датчиком зв’язком один до багатьох (один датчик завжди відповідає одному типу, але можливе існування багатьох датчиків одного типу);
 - вулик пов’язаний з датчиком зв’язком один до багатьох (один вулик може містити багато датчиків, а один датчик належить одному вулику);
- датчик пов’язаний із читанням датчику зв’язком один до багатьох (один датчик може мати багато зчитувань, а одне зчитування відбувається одним датчиком);
- хаб пов'язаний з пасікою зв’язком один до одного (один хаб відповідає одній пасіці).


 
4	РЕАЛІЗАЦІЯ ПРОГРАМНОЇ СИСТЕМИ
4.1	Реалізація серверної частини


Для розробки серверну частину програмної системи використано платформу .NET 6.0 та мову програмування C#, а також технологію ASP.NET Core для розробки Web API.
Для зберігання даних використовується база даних SQL Server. Доступ до даних з серверної частини застосунку відбувається за допомогою технології Entity Framework Core. 
Безпека даних підтримується завдяки хешуванню паролів за допомогою бібліотеки BCrypt.Net. Авторизація користувачів відбувається за допомогою JWT, який генерується застосунком.
Інтернаціоналізація забезпечується шляхом підтримки різних часових поясів (усі дати на сервері зберігаються за часом UTC), можливості вибору різних одиниць вимірювання.
Забезпечено підтримку UTF-8 та ASCII і можливості передачі за зберігання інформації у базі даних різними мовами.
Адміністрування базою даних додатково можна здійснювати програмним шляхом за допомогою звертання до певних кінцевих точок серверної частини.
Під час розробки було використано деякі допоміжні пакети та фреймоворки, такі як Entity Framework Core, ASP.NET Core, ASP.NET Core Identity, Automapper, BCrypt.net, AspNetCore JwtBearer.
Серверна частина розроблена за архітектурним стилем REST. Специфікація усіх кінцевих точок REST API наведена у таблиці 1.




Таблиця 1 – Специфікація REST
Метод	Кінцева точка	Опис
POST	/api/Admin/db/backup	Створення резервної копії бази даних
POST	/api/Admin/db/restore	Відновлення бази даних з резервної копії
GET	/api/Admin/db/lastbackup	Отримання дати останнього резервного копіювання
POST	/api/Apiary	Створення нової пасіки
DELETE	/api/Apiary/{apiaryId}	Видалення пасіки за її ідентифікатором
POST	/api/Apiary/hive	Створення нового вулика
PATCH	/api/Apiary/hive/{hiveId}	Оновлення інформації про вулик за його ідентифікатором
GET	/api/Apiary/user/{userId}	Отримання інформації про пасіки користувача за його ідентифікатором
GET	/api/Apiary/hives	Отримання списку всіх вуликів
GET	/api/Apiary/all	Отримання інформації про всі пасіки
POST	/api/Auth/register	Реєстрація нового користувача
POST	/api/Auth/login	Авторизація користувача
POST	/api/Auth/role	Додавання нової ролі
DELETE	/api/Auth/role	Видалення існуючої ролі


Продовження таблиці 1
POST	/api/Auth/user/role	Призначення ролі користувачу
GET	/api/Equipment/serial/all	Отримання всіх серійних даних
POST	/api/Equipment/serial/{equipmentType}	Додавання нових серійних даних для вказаного типу обладнання
DELETE	/api/Equipment/serial/number/{serialNumber}	Видалення серійних даних за серійним номером
DELETE	/api/Equipment/serial/id/{serialDataId}	Видалення серійних даних за ідентифікатором
POST	/api/Order/status	Додавання нового статусу замовлення
GET	/api/Order/status/all	Отримання всіх статусів замовлень
DELETE	/api/Order/status/{orderStatus}	Видалення статусу замовлення за його назвою
POST	/api/Order	Створення нового замовлення
PATCH	/api/Order/approve/
{orderId}	Підтвердження замовлення за його ідентифікатором
PATCH	/api/Order/complete/{orderId}	Завершення замовлення за його ідентифікатором
PATCH	/api/Order/cancel/{orderId}	Скасування замовлення за його ідентифікатором
GET	/api/Order/user/all/{userId}	Отримання всіх замовлень користувача за його ідентифікатором
GET	/api/Order/all	Отримання всіх замовлень




Продовження таблиці 1
POST	/api/Order/filter	Фільтрація замовлень за вказаними критеріями
POST	/api/Sensor	Додавання нового датчика
POST	/api/Sensor/type	Додавання нового типу датчика
POST	/api/Sensor/readings/hub/{hubId}	Додавання показань датчика для вказаного хабу
DELETE	/api/Sensor/{sensorId}	Видалення датчика за його ідентифікатором
GET	/api/Sensor/daily-average	Отримання середнього значення датчика за день
GET	/api/Sensor/hive/{hiveId}/last	Отримання останніх даних датчика для вулика за його ідентифікатором
GET	/api/Sensor/period	Отримання показань датчика за період
GET	/api/Sensor/type/all	Отримання всіх типів датчиків

Фрагменти коду серверної частини наведені у додатку А.


4.2	Реалізація клієнтської частини


Для створення клієнтської частини використовується платформа Angular, що створена з використанням мови TypeScript, який у свою чергу є розширенням для JavaScript.
Реалізовано підтримку української та англійської мови на більшості сторінках для підтримки локалізації. За локалізацію відповідає сервіс, який отримує данні із заздалегідь підготовлених файлів у форматі json, які містять переклади певних слів та словосполучень, і передає їх у компоненти для відображення.
Реалізовано підтримку різних часових поясів. У налаштуваннях можливо обрати різні часові пояси відносно UTC. Реалізовано підтримку різних форматів дати та часу в усіх частинах застосунку та різних валют. Усі налаштування локалізації та інтернаціоналізації зберігаються локально на пристрої користувачів. Також передбачено переведення одиниць вимірюванння (кілограми у фунти, градуси Цельсія у градуси Фаренгейта і навпаки).
Локалізація та інтернаціоналізація виконана за допомогою засобів, які надає платформа Angular.
Окрім бізнес-логіки реалізовано підтримку адміністрування системи, а саме можливість адміністраторів створювати резервні копії бази даних, переглядати останню дату резервного копіювання та можливість відновлювати базу даних з резервної копії.
Для забезпечення безпеки даних передбачено декілька механізмів. При введенні конфіденційних даних, таких як паролі, вони відображаються на екрані у вигляді, недоступному для читання. При авторизації користувачів використовується технологія JSON Web Token, яка дозволяє зберігати сесію авторизації у зашифрованому вигляді. Паролі між клієнтом та сервером передаються у зашифрованому вигляді.
При користуванні застосунком виключно англійською мовою можливе використання не тільки стандарту кодування UTF-8, а ще й ASCII. 
Фрагменти коду клієнтської браузерної частини наведені у додатку Б.





4.3	Реалізація програмного забезпечення для розумних пристроїв


Для реалізації функціоналу розумних пристроїв у системі "ApexiBee Smart Hive" використовуються різноманітні апаратні та програмні компоненти. Основним контролером є мікроконтролер ESP32, який забезпечує збір і обробку даних з датчиків та зв'язок з іншими елементами системи.
Спочатку відбувається конфігурування пристроїв. Частину конфігурації системи встановлює системний адміністратор чи менеджер, які встановлюють адресу серверу, ідентифікатор мікроконтролера вулика та стандартні критичні значення датчиків. Решту конфігураційної інформації може вносити бджоляр, шляхом отримання конфігурації з серверу. Мікроконтролер вулика може отримувати частину конфігурації з файлу (адреса серверу, ідентифікатор пристрою), а інші частину - з серверу (інші налаштування, такі як критичні значення датчиків, детальна інформація про підключені датчики тощо). Початкова конфігурація виконується при запуску мікроконтролера. При невдалому конфігуруванні робота пристрою припиняється, а користувач отримує відповідне сповіщення. Також можлива конфігурація шляхом натискання на кнопку, для того, щоб оновити дані з серверу та micro SD карти.
Для коректного функціонування пристрій повинен мати стабільний зв'язок з мереженою Інтернет, через яку відбувається уся взаємодія. Додатково через цю мережу відбувається синхронізація часу для коректного відображення дати зчитування з датчиків.
Отримання інформації з підключених датчиків відбувається періодично (раз на декілька секунд), які групуються та відправляються на центральний вузол пасіки. Додаткового для конфігурування пристрій підтримує калібровку ваг таким чином, що вага самого вулика не враховувалася, а зважувався тільки мед. Для цього потрібно натиснути на відповідну кнопку.
Система використовує математичні методи для ефективної роботи. Для коректного збору даних з датчиків розраховується середнє значення вимірів за певний проміжок часу для того, щоб запобігти невірним зчитуванням. На сервер відправляється саме середнє значення. Це також сприяє зменшенню кількість даних у базі даних, а також непотрібної постійної взаємодії та зв'язку між елементами системи. Додатково пристрій отримує з серверу інформацію про критичні значення з певних датчиків та порівнює поточні значення з критичними. При виявленні значення, що менше або більше за критичне, пристній інформує про це користувача, а також може вплинути на мікроклімат всередині вулику для корегування значення температури чи вологості повітря.
Для забезпечення інтернаціоналізації час у системі синхронізується через Інтернет та зберігається у форматі UTC. Це значення і передається далі на сервер.
Фрагменти коду програмного забезпечення для розумних пристроїв наведені у додатку В.


4.4	Реалізація мобільного застосунку


Мобільний застосунок створювався на платформі Xamarin, яка є частиною екосистеми .NET.
У мобільному застосунку реалізовано функціонал для бджолярів. Вони можуть змінювати дані профілю, взаємодіяти з власними пасіками та вуликами, відстежувати параметри датчиків та отримувати повідомлення про досягненні критичних значень.
Реалізовано підтримку української та англійської мови на усіх сторінках для підтримки локалізації. За локалізацію відповідає розширення, яке отримує данні із заздалегідь підготовлених файлів статичних ресурсів, які містять переклади певних слів та словосполучень у вигляді ключів та локалізованих значень. Це розширення дозволяє відображати перекладені мовні конструкції одразу у відображення за допомогою мови XAML. Мова визначається за встановленою у системі Android локалізацію під час запуску застосунку.
Реалізовано підтримку різних часових поясів. Локальний час визначається за встановленим у системі Android часовим поясом. У профілі користувача можна переглянути встановлений часовий пояс та час авторизації за локальним часом. Також підтримується відображення дати у форматах місяць - день і день - місяць.
Для забезпечення безпеки даних передбачено декілька механізмів. При введенні конфіденційних даних, таких як паролі, вони відображаються на екрані у вигляді, недоступному для читання. При авторизації користувачів використовується технологія JSON Web Token, яка дозволяє зберігати сесію авторизації у зашифрованому вигляді. Паролі між клієнтом та сервером передаються у зашифрованому вигляді.
При користуванні застосунком виключно англійською мовою можливе використання не тільки стандарту кодування UTF-8, а ще й ASCII. 
Мобільний застосунок повністю інтегрований в систему. Усі зміни, які вносяться з Android пристроїв відображаються у браузерному клієнтському застосунку та у базі даних на сервері.
Фрагменти коду мобільного застосунку наведені у додатку Г.

 
5	ОПИС СТВОРЕНОЇ СИСТЕМИ
5.1	Опис серверної частини


Реалізована серверна частина надає інтерфейс для взаємодії з іншими частинами системи у вигляді REST API.
Запуск серверного застосунку можливий на пристрої з виходом у мережу Інтернет та встановленим пакетом .NET Runtime з підтримкою ASP.NET Core. Перед цим необхідно налаштувати строку підключення до бази даних у конфігураційному файлі, а також встановити порти для запуску застосунку. 
Можлива публікація серверної частини у хмарний сервіс Azure засобами Visual Studio або вручну. Для цього необхідно створити відповідний простір у хмарі, створити у хмарі базу даних SQL Server, після цього розгорнути серверний застосунок з налаштованою строкою підключенння до створеної бази даних.

5.2	Опис клієнтської частини

Клієнтська частина, створена за допомогою Angular, надає користувачеві графічний інтерфейс для взаємодії з системою. Доступ до нього користувач може отримати через браузер, ввівши в адресну строку адресу серверу, на якому розгорнуто клієнтський застосунок. У клієнтському браузерному застосунку реалізовано функціонал для бджолярів, менеджерів та адміністраторів. Усі можливі дії користувачів наведено на діаграмі прецедентів клієнтської частини (рисунок 5.1).
Деталізована схема взаємодії користувача з системою наведена на діаграмі діяльності (рисунок 5.2). На ній відображено потік виконання програми бджоляром.

 
Рисунок 5.1 – Діаграма прецедентів для клієнтської частини системи

 
Рисунок 5.2 – Діаграма діяльності користувача клієнтської частини
Після заходу користувач потрапляє на головну сторінку (рис. 5.3). Після цього є можливість авторизиації (рис. 5.4) та реєстрації (рис. 5.5). Неавторизований користувач також може змінити налаштування мови одразу на головній сторінці.

 
Рисунок 5.3 – Головна сторінка клієнтської частини

 
Рисунок 5.4 – Форма авторизації

 
Рисунок 5.5 – Форма реєстрації

Після успішної авторизації користувачу стають доступними додаткові налаштування системи, такі як вибір формату відображення часу, дати та можливість обрати часовий пояс (рисунок 5.6). Після зміни та підтвердження налаштувань мова інтерфейсу одразу змінюється (рисунок 5.7).

 
Рисунок 5.6 – Сторінка налаштувань системи

 
Рисунок 5.7 – Зміна мови інтерфейсу після зміни налаштувань

	Для початку роботи користувачу необхідно натиснути кнопку початку роботи. Після цього користувач потрапляє у роботу область з боковим меню для вибору категорії функцій.
Авторизований адміністратор може взаємодіяти зі списком менеджерів та базою даних. Для роботи з менеджерами у боковому меню необхідно обрати відповідний пункт. Після цього користувач потрапляє на сторінку зі списком менеджерів (рисунок 5.8).

 
Рисунок 5.8 – Сторінка зі списком менеджерів
Для додавання менеджерів необхідно натиснути на кнопку з плюсом. Після цього користувачу відкриється спливаюче вікно для додавання менеджера (рисунок 5.9). Після введення усіх потрібних даних необхідно натиснути на кнопку для додавання менеджера.

 
Рисунок 5.9 – Вікно для додавання менеджера

Адміністратору доступний функціонал для роботи з базою даних (рисунок 5.10). На цій сторінці є можливість створювати резервні копії та відновлювати дані

 
Рисунок 5.10 – Сторінка для роботи з базою даних
Авторизований менеджер може працювати зі списком замовлень та з обладнанням.
Для роботи з замовленнями необхідно обрати відповідний пункт у меню. Після цього користувач потрапляє на сторінку з замовленнями (рисунок 5.11). Для додавння замовлення необхідно натиснути на кнопку «Створити замовлення».

 
Рисунок 5.11 – Сторінка з замовленнями

 
Рисунок 5.12 – Вікно для створення нового замовлення
	Менеджер може опрацьовувати окремі замовлення. Для цього необхідно натиснути на кнопку «Обробити замовлення». Після цього відкриється вікно з детальною інформацією про замовлення (рисунок 5.13). Статус замовлення можна змінювати тільки у певній послідовності. Виконане замовлення не може бути скасовано, а вже підтверджене замовлення не можливо підтвердити знову.

 
Рисунок 5.13 – Вікно для обробки замовлення

Також менеджеру доступний функціонал роботи з обладнанням. Менеджер може переглядати список доданого обладнання (рисунок 5.14) та реєструвати нове обладнання (рисунок 5.15). Усього існує 3 типи обладнання: вулик, хаб та датчик. Серійний номер генерується автоматично.

 
Рисунок 5.14 – Сторінка зі списком існуючого обладнання

 
Рисунок 5.15 – Вікно для додавання обладнання

Авторизований бджоляр може працювати зі своїми пасіками та замовленнями.
Для роботи з замовленнями необхідно обрати відповідний пункт у меню. Після цього користувач потрапляє на сторінку зі списком замовлень 
(рисунок 5.16).


 
Рисунок 5.16 – Сторінка зі списком замовлень клієнта

	Також користувач має доступ до списку власних пасік (рис. 5.17). Форма для створення пасіки відображена на рисунку 5.18. Для додавання нової пасіки до створеної пасіки треба прив’язати пристрій «Хаб» та ввести його серійний номер. Також необхідно ввести критичні значення датчиків або обрати значення за замовченням.

 
Рисунок 5.17 – Сторінка зі списком пасік користувача

 
Рисунок 5.18 – Форма для додавання пасіки

	Бджоляр може отримати детальну інформацію про пасіку, натисшувши на кнопку «Деталі» (рисунок 5.19).

 
Рисунок 5.19 – Сторінка з детальною інформацією про пасіку




	На сторінці з детальною інформацію про пасіку можна додати новий вулик (рисунок 5.20).

 
Рисунок 5.20 – Форма для додавання вулика

Також користувач може отримати отримати детальну інформацію про вулик. На сторінці з детальною інформацією про вулик також можна отримати дані з датчиків, відображені на графіку (рисунок 5.21).

 
Рисунок 5.21 – Сторінка з детальною інформацією про вулик
5.3	Опис взаємодії з розумними пристроями


У систему інтегровано роботу розумних пристроїв. Можна виділити два розумних пристрої: хаб та вулик.
Можна виділити декілька категорій користувачів, що напряму взаємодіють з цією підсистемою: адміністратор та бджоляр. Додатково на діаграмі вулик так центральний вузол пасіки відображені як окремі актори, так як можуть самостійно виконувати певні дії. Діаграма прецедентів відображена на рисунку 5.22.
Бджоляр має можливість встановлювати зв'язок між пристроями та налаштовувати пристрої (з карти пам'яті чи серверу). Він також може отримувати інформацію з датчиків, таку як вологість повітря у вулику, активність бджіл, температуру та вагу меду у вуликах. Крім того, бджоляр отримує сповіщення про критичні показники вологості та температури у вуликах.
Адміністратор системи може змінювати налаштування датчиків чи вуликів на сервері, налаштовувати загальну конфігурацію системи.
Вулик збирає дані з датчиків, таких як температура, вологість у вулику, активність бджіл та вага меду у вуликах. Він групує та розраховує середнє значення з датчиків за короткий проміжок часу та надсилає ці дані до хабу. Також вулик отримує конфігурацію з сервера чи карти пам'яті, підключає датчики та змінює мікроклімат у вулику при критичних значеннях датчиків.
Центральний вузол пасіки групує дані з усіх підключених вуликів та надсилає дані з вуликів на сервер. 





 
Рисунок 5.22 – Діаграма прецедентів для розумних пристроїв 
програмної системи ApexiBee

У системі відбувається обмін повідомлень між вуликом, хабом та сервером. Процес обміну повідомленнями відображено на рисунку 5.23.

 
Рисунок 5.23 – Діаграма взаємодії між елементами розумними пристроями та іншими елементами системи

Процес роботи розумного вулика продемонстровано на діаграмі діяльності (рисунок 5.24). На ній відображено процес взаємодії та роботи розумного вулика, включаючи увімкнення та вимкнення пристрою, підключення до Wi-Fi, перевірку з'єднання з хабом, отримання конфігурацій, налаштування пінів, калібрування ваг, обробку отриманих даних з датчиків тощо.

 
Рисунок 5.24 - Діаграма діяльності для демонстрації роботи 
розумного вулика



5.4	Опис взаємодії з мобільним застосунком

Мобільний застосунок призначений в першу чергу для бджолярів. Також він містить певний функціонал для менеджерів. Можливі дії користувачів мобільного застосунку відображені на рисунку 5.24 у вигляді діаграми прецедентів.

 
Рисунок 5.24 – Діаграма можливих дій користувачів 
мобільного додатку

Для деталізації взаємодії бджоляра з системою була створена діаграма діяльності (рисунок 5.25). Діаграма діяльності демонструє процес взаємодії користувача з системою. Вона дозволяє побачити потік виконання програми. На цій діаграмі продемонстровано роботу бджоляра з мобільним застосунком.
Спочатку бджоляр має авторизуватися у системі (рисунок 5.26). Якщо користувач ввів коректні дані, то він потрапляє на головну сторінку.
Якщо користувач обирає пункт меню зі списком пасік, то він потрапляє на сторінку зі списків своїх пасік (рисунок 5.27). Якщо натиснути на будь-яку пасіку, то можна отримати детальну інформацію про неї (рисунок 5.28). На цій сторінці користувач може ознайомитись з показниками датчиків та чи перевищують вони критичні значення.
Якщо користувач обирає пункт меню з профілем, то він потрапляє у профіль користувача (рисунок 5.29). Тут відображається інформація про нього та налаштування локалізації. Користувач може змінити інформацію у профілі. Після підтвердження змін профіль оновлюється.
Якщо користувач обирає пункт меню "вийти з акаунту", то користувач може ввести нові дані для входу.

 
Рисунок 5.25 – Діаграма діяльності для відображення потоку 
керування бджоляра

 
Рисунок 5.26 – Сторінка авторизації

 
Рисунок 5.27 – Сторінка зі списком пасіками
 
Рисунок 5.28 – Сторінка зі списком вуликів пасіки

 
Рисунок 5.29 – Профіль користувача
Також у системі присутня локалізація українською та англійською мовами. Після зміни системної мови інтерфейс застосунку перекладається українською (рисунок 5.30)

 
Рисунок 5.30 – Сторінка авторизації перекладена українською мовою


 
ВИСНОВКИ


Під час курсового проектування було на практиці засвоєно процес проектування архітектури та створення програмних систем, що складаються з декількох взаємопов’язаних між компонентів, використовуючи різні технології у кожній з частин, на прикладі створення програмної систему для моніторингу та керування пасікою
В ході виконання роботи було проаналізовано предмету область, визначено основні категорії користувачів системи (бджолярі, менеджери, адміністратори) та їх потреби. Результат аналізу представлені у вигляді детального опису функції, які треба реалізувати у системі. Після цього було спроектовано та розроблено інформаційну систему. Вона складається з серверної частини з базою даних, клієнтської браузерної частини, розумних пристроїв та мобільного застосунку. Усі частини системи були розроблені за принципами чистої масштабованої архітектури. У кожній з частин використовуються свої архітектурні стилі та патерни. Також під час проектування та розробки були дотримані принципи DRY, KISS, SOLID та інші.
Для реалізації системи були використані різноманітні технології. Серверна частина була реалізована за допомогою ASP.NET Core та платформи .NET 6 з використанням СУБД MS SQL Server. Клієнтська частина створена за допомогою фреймворку Angular 16. Програмне забезпечення для розумних пристроїв написане на мові C++ з використанням допоміжних бібліотек для програмування контролера ESP-32. Мобільний застосунок створений за допомогою Xamarin, який є частиною платформи .NET.
Створена система відповідає поставленим вимогам та потребам потенційних користувачів та може бути використана для автоматизації процесів на пасіці.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Мартін Р. Чистий код: створення і рефакторинг за допомогою 
AGILE. – Харків: Фабула, 2019. – 416 с.
2. Krzystof Cwalina, Brad Abrams. Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries. – Addison-Wesley Professional, 2009. – 436 p.
3. Мартін Р. Чиста архітектура: Мистецтво розроблення програмного забезпечення / пер. з англ. І. Бондар-Терещенко.  –  Харків: Фабула, 2021. – 
368 с.
4. Методичні вказівки до курсової роботи з навчальної дисципліни «Архітектура програмного забезпечення» для студентів усіх форм навчання спеціальності 121 – «Інженерія програмного забезпечення» / Упоряд. В.О. Лещинський, І.О. Лещинська, І.П. Сокорчук – Харків: ХНУРЕ, 2021. – 37 с.
5. .NET Documentation. URL: https://learn.microsoft.com/en-us/dotnet/ (Дата звернення 12.06.2024).
     
 
ДОДАТОК А
Фрагменти коду серверної частини
А.1 Програмний код запуску серверу

1.	using ApexiBee.Persistance.Database;
2.	using ApexiBee.Persistance.EntityConfiguration;
3.	using ApexiBee.Domain.Models;
4.	
5.	using Microsoft.EntityFrameworkCore;
6.	using Microsoft.AspNetCore.Identity;
7.	using ApexiBee.Application.Interfaces;
8.	using ApexiBee.Infrastructure.Implementation.Services;
9.	using ApexiBee.Infrastructure.Implementation.Repositories;
10.	using ApexiBee.Infrastructure.Interfaces;
11.	using ApexiBee.Application.Helpers;
12.	using ApexiBee.Application.DomainServices;
13.	using ApexiBee.API.Middleware;
14.	using Microsoft.SqlServer.Management.Smo.Wmi;
15.	using AutoMapper;
16.	using ApexiBee.Infrastructure.Implementation.AutoMapper;
17.	using ApexiBee.Infrastructure.Implementation.Helpers;
18.	
19.	var builder = WebApplication.CreateBuilder(args);
20.	
21.	var Configuration = builder.Configuration;
22.	
23.	builder.Services.AddControllers();
24.	// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
25.	builder.Services.AddEndpointsApiExplorer();
26.	builder.Services.AddSwaggerGen();
27.	
28.	builder.Services.AddDbContext<BeeDbContext>(options =>
29.	{
30.	    options.UseSqlServer(Configuration.GetConnectionString("default"), b => b.MigrationsAssembly("ApexiBee.Persistance"));
31.	});
32.	
33.	// Configuring identity using ASP.NET Core Identity
34.	builder.Services
35.	    .AddIdentity<ApplicationUser, IdentityRole<Guid>>(options =>
36.	    {
37.	        options.Password.RequireDigit = true;
38.	        options.Password.RequireNonAlphanumeric = false;
39.	        options.Password.RequireUppercase = false;
40.	        options.Password.RequiredLength = 6;
41.	        options.Password.RequiredUniqueChars = 0;
42.	    })
43.	    .AddEntityFrameworkStores<BeeDbContext>()
44.	    .AddDefaultTokenProviders();
45.	
46.	// Add services to the container (services dependency injection).
47.	builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();
48.	builder.Services.AddScoped<IDatabaseService, DatabaseService>();
49.	builder.Services.AddScoped<IAuthService, AuthService>();
50.	builder.Services.AddScoped<IRoleService, RoleService>();
51.	builder.Services.AddScoped<IOrderService, OrderService>();
52.	builder.Services.AddScoped<IApiaryService, ApiaryService>();
53.	builder.Services.AddScoped<IEquipmentService, EquipmentService>();
54.	builder.Services.AddScoped<ISensorService, SensorService>();
55.	builder.Services.AddSingleton<ConfigurationHelper>();
56.	
57.	builder.Services.AddScoped<JwtHelper>();
58.	
59.	var mapperConfig = new MapperConfiguration(mc =>
60.	{
61.	    mc.AddProfile(new MapperProfile());
62.	});
63.	
64.	IMapper mapper = mapperConfig.CreateMapper();
65.	builder.Services.AddSingleton(mapper);
66.	
67.	
68.	var app = builder.Build();
69.	
70.	// Configure the HTTP request pipeline.
71.	if (app.Environment.IsDevelopment())
72.	{
73.	    app.UseSwagger();
74.	    app.UseSwaggerUI();
75.	}
76.	
77.	app.UseMiddleware<ErrorHandlingMiddleware>();
78.	
79.	app.UseHttpsRedirection();
80.	
81.	app.UseAuthorization();
82.	
83.	app.MapControllers();
84.	
85.	app.Run();


А.2 Програмний код інтерфейсу сервісу для роботи з обладнанням

1.	public interface IEquipmentService
2.	{
3.	    /// <summary>
4.	    /// Retrieves all serial data.
5.	    /// </summary>
6.	    /// <returns>A task that represents the asynchronous operation. The task result contains an IEnumerable of SerialData.</returns>
7.	    Task<IEnumerable<SerialData>> GetAllSerialData();
8.	        
9.	    /// <summary>
10.	    /// Adds new serial data for the specified equipment type.
11.	    /// </summary>
12.	    /// <param name="equipmentType">The type of the equipment for which to add serial data.</param>
13.	    /// <returns>A task that represents the asynchronous operation. The task result contains the added SerialData.</returns>
14.	    Task<SerialData> AddNewSerialData(EquipmentType equipmentType);
15.	
16.	    /// <summary>
17.	    /// Removes serial data by its serial number.
18.	    /// </summary>
19.	    /// <param name="serialNumber">The serial number of the serial data to remove.</param>
20.	    /// <returns>A task that represents the asynchronous operation.</returns>
21.	    Task RemoveSerialDataByName(string serialNumber);
22.	
23.	    /// <summary>
24.	    /// Removes serial data by its ID.
25.	    /// </summary>
26.	    /// <param name="serialDataid">The ID of the serial data to remove.</param>
27.	    /// <returns>A task that represents the asynchronous operation.</returns>
28.	    Task RemoveSerialDataById(Guid serialDataid);
29.	
30.	    /// <summary>
31.	    /// Generates a unique serial number.
32.	    /// </summary>
33.	    /// <returns>A unique serial number as a string.</returns>
34.	    string GenerateUniqueSerialNumber();
35.	
36.	    /// <summary>
37.	    /// Gets the string representation of the equipment name based on the equipment type.
38.	    /// </summary>
39.	    /// <param name="type">The equipment type.</param>
40.	    /// <returns>The string representation of the equipment name.</returns>
41.	    string GetStringEquipmentName(EquipmentType type);
}


А.3 Програмний код сервісу для роботи з датчиками

1.	public class SensorService : ServiceBase, ISensorService
2.	{
3.	    public SensorService(IUnitOfWork unitOfWork) : base(unitOfWork)
4.	    { }
5.	
6.	    public async Task<Sensor> AddNewSensor(NewSensorData newSensorData)
7.	    {
8.	        SensorType? foundSensorType = await unitOfWork.SensorTypeRepository.GetByIdAsync(newSensorData.SensorTypeId);
9.	        if (foundSensorType == null)
10.	        {
11.	            throw new NotFoundException("sensor type");
12.	        }
13.	
14.	        Sensor newSensor = new Sensor()
15.	        {
16.	            SensorTypeId = newSensorData.SensorTypeId,
17.	            HiveId = newSensorData.HiveId
18.	        };
19.	
20.	        await unitOfWork.SensorRepository.AddAsync(newSensor);
21.	        await unitOfWork.SaveAsync();
22.	
23.	        return newSensor;
24.	    }
25.	
26.	    public async Task<SensorType> AddNewSensorType(NewSensorTypeData newSensorTypeData)
27.	    {
28.	        SensorType sensorType = new SensorType()
29.	        {
30.	            Description = newSensorTypeData.Description,
31.	            Name = newSensorTypeData.Name,
32.	            MeasureUnit = newSensorTypeData.MeasureUnit
33.	        };
34.	
35.	        await unitOfWork.SensorTypeRepository.AddAsync(sensorType);
36.	        await unitOfWork.SaveAsync();
37.	        return sensorType;
38.	    }
39.	
40.	    public async Task<(int, int)> AddSensorReadings(IEnumerable<NewSensorReading> readings, Guid senderHubId)
41.	    {
42.	        int totalReadings = readings.Count();
43.	        int addedReadings = 0;
44.	        HubStation? foundHub = await unitOfWork.HubStationRepository.GetByIdAsync(senderHubId);
45.	        if(foundHub == null)
46.	        {
47.	            throw new NotFoundException(senderHubId, "hub station");
48.	        }
49.	
50.	        Guid[] sensorIds = unitOfWork.SensorRepository.GetAll().Select(e => e.Id).ToArray();
51.	
52.	        foreach(NewSensorReading reading in readings)
53.	        {
54.	            if (sensorIds.Contains(reading.SensorId))
55.	            {
56.	                SensorReading newReading = new SensorReading()
57.	                {
58.	                    SensorId = reading.SensorId,
59.	                    Value = reading.Value,
60.	                    ReadingDate = reading.ReadingDate
61.	                };
62.	                await unitOfWork.SensorReadingRepository.AddAsync(newReading);
63.	                addedReadings += 1;
64.	            }
65.	        }
66.	
67.	        await unitOfWork.SaveAsync();
68.	        return (addedReadings, totalReadings);
69.	    }
70.	
71.	    public async Task DeleteSensor(Guid sensorId)
72.	    {
73.	        try
74.	        {
75.	            await unitOfWork.SensorRepository.DeleteByIdAsync(sensorId);
76.	        }
77.	        catch (InvalidOperationException) 
78.	        {
79.	            throw new NotFoundException(sensorId, "sensor");
80.	        }
81.	    }
82.	
83.	    public async Task<SensorCountedResult> GetAverageDailySensorValue(Guid sensorId, DateTime date)
84.	    {
85.	        Sensor? foundSensor = await unitOfWork.SensorRepository.GetByIdAsync(sensorId);
86.	        if(foundSensor == null)
87.	        {
88.	            throw new NotFoundException(sensorId, "sensor");
89.	        }
90.	
91.	        SensorType sensorType = (await unitOfWork.SensorTypeRepository.GetByIdAsync(foundSensor.SensorTypeId))!;
92.	
93.	        IEnumerable<SensorReading> sensorReadings = unitOfWork.SensorReadingRepository
94.	            .GetAll().Where(e => e.ReadingDate.Date == date.Date && e.SensorId == sensorId).ToList();
95.	
96.	        if(!sensorReadings.Any())
97.	        {
98.	            SensorCountedResult incorrectResult = new SensorCountedResult()
99.	            {
100.	                SensorId = sensorId,
101.	                SensorTypeId = foundSensor.SensorTypeId,
102.	                Value = null,
103.	                SensorType = sensorType.Name,
104.	                MeasureUnit = sensorType.MeasureUnit
105.	            };
106.	            return incorrectResult;
107.	        }
108.	
109.	        double calculatedValue = CalculateWeightedAverage(sensorReadings.ToArray());
110.	
111.	        SensorCountedResult result = new SensorCountedResult()
112.	        {
113.	            SensorId = sensorId,
114.	            SensorTypeId = foundSensor.SensorTypeId,
115.	            Value = calculatedValue,
116.	            SensorType = sensorType.Name,
117.	            MeasureUnit = sensorType.MeasureUnit
118.	        };
119.	        return result;
120.	
121.	    }
122.	
123.	    public async Task<IEnumerable<SensorReading>> GetLastHiveSensorData(Guid hiveId)
124.	    {
125.	        Hive? foundHive = await unitOfWork.HiveRepository.GetByIdWithAllDetailsAsync(hiveId);
126.	        if(foundHive == null)
127.	        {
128.	            throw new NotFoundException(hiveId, "hive");
129.	        }
130.	
131.	        Guid[] sensorIds = foundHive.Sensors.Select(e => e.Id).ToArray();
132.	        IEnumerable<SensorReading> hiveSensorReadings = unitOfWork.SensorReadingRepository
133.	            .GetAll().Where(e => sensorIds.Contains(e.SensorId)).ToList();
134.	
135.	        IEnumerable<SensorReading> lastSensorReadings = hiveSensorReadings
136.	            .GroupBy(e => e.SensorId)
137.	            .Select(g => g.OrderByDescending(e => e.ReadingDate).First())
138.	            .ToList();
139.	
140.	        return lastSensorReadings;
141.	    }
142.	    public async Task<IEnumerable<SensorReading>> GetSensorReadingsWithinPeriod(Guid sensorId, DateTime start, DateTime end)
143.	    {
144.	        Sensor? foundSensor = await unitOfWork.SensorRepository.GetByIdAsync(sensorId);
145.	        if(foundSensor == null)
146.	        {
147.	            throw new NotFoundException(sensorId, "sensor");
148.	        }
149.	
150.	        IEnumerable<SensorReading> sensorReadingsWithinPeriod = unitOfWork.SensorReadingRepository
151.	            .GetAll().Where(e => e.SensorId == sensorId && e.ReadingDate >= start && e.ReadingDate <= end).ToList();
152.	
153.	        return sensorReadingsWithinPeriod;
154.	    }
155.	
156.	    public async Task<IEnumerable<SensorType>> GetSensorTypes()
157.	    {
158.	        var sensorTypes = unitOfWork.SensorTypeRepository.GetAll().ToList();
159.	        return sensorTypes;
160.	    }
161.	
162.	    private double CalculateWeightedAverage(SensorReading[] readings)
163.	    {
164.	        if (readings == null || readings.Length == 0)
165.	            throw new ArgumentException("The readings array is empty or null.");
166.	
167.	        var sortedReadings = readings.OrderBy(r => r.ReadingDate).ToArray();
168.	        double weightedSum = 0;
169.	        double totalWeight = 0;
170.	
171.	        for (int i = 0; i < sortedReadings.Length - 1; i++)
172.	        {
173.	            var currentReading = sortedReadings[i];
174.	            var nextReading = sortedReadings[i + 1];
175.	
176.	            double timeInterval = (nextReading.ReadingDate - currentReading.ReadingDate).TotalMinutes;
177.	
178.	            double weight = timeInterval;
179.	
180.	            weightedSum += currentReading.Value * weight;
181.	            totalWeight += weight;
182.	        }
183.	        // Calculating last reading
184.	        if (sortedReadings.Length > 1)
185.	        {
186.	            var lastReading = sortedReadings.Last();
187.	
188.	            // We assume that the last reading is valid until the end of the day
189.	            double lastWeight = (DateTime.Today.AddDays(1) - lastReading.ReadingDate).TotalMinutes;
190.	
191.	            weightedSum += lastReading.Value * lastWeight;
192.	            totalWeight += lastWeight;
193.	        }
194.	        return weightedSum / totalWeight;
195.	    }
196.	}
ДОДАТОК Б
Фрагменти коду клієнтської частини
Б.1 Програмний код компоненту для роботи з вуликами

1.	import { DatePipe } from '@angular/common';
2.	import { Component, OnInit, QueryList, ViewChildren } from '@angular/core';
3.	import { ActivatedRoute, Router } from '@angular/router';
4.	import { Chart } from 'chart.js';
5.	import { ConfirmationService, MessageService } from 'primeng/api';
6.	import { forkJoin } from 'rxjs';
7.	import { ApiaryService } from 'src/app/services/api/apiary.service';
8.	import { AuthService } from 'src/app/services/api/auth.service';
9.	import { SensorService } from 'src/app/services/api/sensor.service';
10.	import { ConverterService } from 'src/app/services/converter.service';
11.	import { LocalizationService } from 'src/app/services/localization.service';
12.	import { Hive } from 'src/app/shared/models/hive';
13.	import { Sensor, SensorReading } from 'src/app/shared/models/sensor';
14.	
15.	@Component({
16.	  providers: [DatePipe],
17.	  selector: 'app-hive-details-page',
18.	  templateUrl: './hive-details-page.component.html',
19.	  styleUrls: ['./hive-details-page.component.scss']
20.	})
21.	export class HiveDetailsPageComponent implements OnInit {
22.	    currentHive!: Hive
23.	    hiveSensors!: Sensor[]
24.	    dateFormat!: string;
25.	    lastReadings: SensorReading[] = []
26.	
27.	    @ViewChildren('chart1', { read: Chart }) chart1!: QueryList<Chart>;
28.	    @ViewChildren('chart2', { read: Chart }) chart2!: QueryList<Chart>;
29.	    @ViewChildren('chart3', { read: Chart }) chart3!: QueryList<Chart>;
30.	    @ViewChildren('chart4', { read: Chart }) chart4!: QueryList<Chart>;
31.	
32.	    // chart
33.	    data: any = [];
34.	    options: any;
35.	
36.	    temperatureUnits = "°C";
37.	    weightUnits = "kg";
38.	
39.	    constructor(
40.	        private router: Router,
41.	        private messageService: MessageService,
42.	        private confirmationService: ConfirmationService,
43.	        private converterService: ConverterService,
44.	        public localizationService: LocalizationService, 
45.	        private route: ActivatedRoute, 
46.	        private datePipe: DatePipe,
47.	        private authService : AuthService, 
48.	        private sensorService: SensorService, 
49.	        private apiaryService: ApiaryService) {
50.	    }
51.	
52.	    ngOnInit(): void {
53.	        this.dateFormat = this.localizationService.getCorrectLocalizedDateFormat();
54.	        this.route.params.subscribe(params => {
55.	            const hiveId = params['id'];
56.	            this.apiaryService.getHiveById(hiveId).subscribe((res) => {
57.	                this.currentHive = res;
58.	            })
59.	            this.sensorService.getAllHiveSensors(hiveId).subscribe((res) => {
60.	                this.hiveSensors = res;
61.	
62.	                const observables = this.hiveSensors.map(sensor =>
63.	                    this.sensorService.getSensorWithType(sensor.id)
64.	                  );
65.	                  
66.	                  forkJoin(observables).subscribe(responses => {
67.	                    for (let i = 0; i < this.hiveSensors.length; i++) {
68.	                      const sensor = this.hiveSensors[i];
69.	                      sensor.sensorType = responses[i].sensorType;
70.	                    }
71.	
72.	                    this.fillSensorData();
73.	                  });
74.	
75.	            })
76.	            
77.	            this.sensorService.getLastHiveSensorReadings(hiveId).subscribe((res) => {
78.	                this.lastReadings = res;
79.	            })
80.	        })
81.	
82.	        const documentStyle = getComputedStyle(document.documentElement);
83.	        const textColor = documentStyle.getPropertyValue('--text-color');
84.	        const textColorSecondary = documentStyle.getPropertyValue('--text-color-secondary');
85.	        const surfaceBorder = documentStyle.getPropertyValue('--surface-border');
86.	
87.	        this.options = {
88.	            maintainAspectRatio: false,
89.	            aspectRatio: 0.9,
90.	            plugins: {
91.	                legend: {
92.	                    labels: {
93.	                        color: textColor
94.	                    }
95.	                }
96.	            },
97.	            scales: {
98.	                x: {
99.	                    ticks: {
100.	                        color: textColorSecondary
101.	                    },
102.	                    grid: {
103.	                        color: surfaceBorder,
104.	                        drawBorder: false
105.	                    }
106.	                },
107.	                y: {
108.	                    ticks: {
109.	                        color: textColorSecondary
110.	                    },
111.	                    grid: {
112.	                        color: surfaceBorder,
113.	                        drawBorder: false
114.	                    }
115.	                }
116.	            }
117.	        };
118.	
119.	    }
120.	
121.	    getSensorLastReading(sensorId: string) {
122.	        for (let reading of this.lastReadings) {
123.	            if(reading.sensorId == sensorId) {
124.	                return reading;
125.	            }
126.	        }
127.	
128.	        return null;
129.	    }
130.	
131.	    getReadingDate(sensorReading : SensorReading | null) {
132.	        return sensorReading?.readingDate;
133.	    }
134.	
135.	    getLocalizedValue(sensorType: string, value: number) {
136.	        return value; 
137.	    }
138.	
139.	    getCorrectActualLocalizedUnits(sensor: Sensor) {
140.	        if(sensor.sensorType?.name == "temperature") {
141.	            return this.temperatureUnits;
142.	        }
143.	
144.	        if(sensor.sensorType?.name == "weight") {
145.	            return this.weightUnits;
146.	        }
147.	
148.	        else {
149.	            return sensor.sensorType?.measureUnit;
150.	        }
151.	    }
152.	
153.	    // chart visualizing
154.	    calculateVisualizingData(sensorReadings: SensorReading[], isTemp: boolean, isWeight: boolean) {
155.	        const documentStyle = getComputedStyle(document.documentElement);
156.	
157.	        for (let reading of sensorReadings) {
158.	            console.log(reading.readingDate);
159.	            reading.readingDate = new Date(reading.readingDate);
160.	        }
161.	
162.	        console.log(sensorReadings);
163.	
164.	        sensorReadings = sensorReadings.sort((a, b) => a.readingDate.getTime() - b.readingDate.getTime());
165.	
166.	        let chartData: number[] = []
167.	        let chartLabels: any[] = []
168.	
169.	        sensorReadings.forEach(item => {
170.	            chartLabels.push(this.transformDate(item.readingDate));
171.	            var chartValue = item.value;
172.	            if(isTemp) {
173.	                if(this.temperatureUnits == "°F") {
174.	                    chartValue = this.converterService.celsiusToFahrenheit(item.value);
175.	                }
176.	            }
177.	
178.	            if(isWeight) {
179.	                if(this.weightUnits == "lb") {
180.	                    chartValue = this.converterService.kilogramsToPounds(item.value);
181.	                }
182.	            }
183.	
184.	            chartData.push(chartValue);
185.	        });
186.	
187.	        let data = {
188.	            labels: chartLabels,
189.	            datasets: [
190.	                {
191.	                    label: 'Sensor reading',
192.	                    data: chartData,
193.	                    fill: false,
194.	                    borderColor: documentStyle.getPropertyValue('--blue-500'),
195.	                    tension: 0.4
196.	                },
197.	            ]
198.	        };
199.	        
200.	        console.log(data);
201.	
202.	        return data;
203.	    }
204.	
205.	    transformDate(date: Date) {
206.	        var correctDate = this.localizationService.getCorrectLocalizedDate(date);
207.	        var timeFormat = this.localizationService.getCurrentTimeFormat()?.format;
208.	        var dateFormat = this.localizationService.getCurrentDataFormat()?.value;
209.	        console.log(timeFormat, dateFormat);
210.	        return this.datePipe.transform(correctDate, timeFormat + " " + dateFormat);
211.	    }
212.	
213.	    fillSensorData() {
214.	        var currentMoment = new Date();
215.	        var twentyFourHoursAgo  = new Date(currentMoment.getTime() - (24 * 60 * 60 * 1000));
216.	        for (let i = 0; i < this.hiveSensors.length; i++) {
217.	            let sensor = this.hiveSensors[i];
218.	            let currentIndex = i;
219.	            this.sensorService.getSensorReadingDuringPeriod(sensor.id, twentyFourHoursAgo, currentMoment).subscribe((res) => {
220.	                var sensorData = res;
221.	                if(sensor.sensorType?.name == "temperature") {
222.	                    var calculatedChartData = this.calculateVisualizingData(sensorData, true, false);
223.	                    this.data[currentIndex] = calculatedChartData;
224.	                }
225.	                else if(sensor.sensorType?.name == "weight") {
226.	                    var calculatedChartData = this.calculateVisualizingData(sensorData, false, true);
227.	                    this.data[currentIndex] = calculatedChartData;
228.	                }
229.	                else {
230.	                    var calculatedChartData = this.calculateVisualizingData(sensorData, false, false);
231.	                    this.data[currentIndex] = calculatedChartData;
232.	                }
233.	
234.	            })
235.	        }
236.	    }
237.	
238.	    onUnitChanged() {
239.	        this.fillSensorData();
240.	    }
241.	
242.	    getCorrectSensorValue(sensorValue: number, sensorType: string) {
243.	        if(sensorType == "temperature") {
244.	            if(this.temperatureUnits == "°F") {
245.	                return this.converterService.celsiusToFahrenheit(sensorValue);
246.	            }
247.	        }
248.	
249.	        if(sensorType == "weight") {
250.	            if(this.weightUnits == "lb") {
251.	                return this.converterService.kilogramsToPounds(sensorValue);
252.	            }
253.	        }
254.	
255.	        return sensorValue;
256.	    }
257.	
258.	    activateHive() {
259.	        this.apiaryService.checkHive(this.currentHive.id).subscribe(() => {
260.	            this.apiaryService.getHiveById(this.currentHive.id).subscribe((res) => {
261.	                this.currentHive = res;
262.	            })
263.	        });
264.	    }
265.	
266.	    onDeleteButtonClicked() {
267.	        this.confirmationService.confirm({
268.	            message: `Are you really want to delete this hive with all sensors?`,
269.	            header: "Delete confirmation",
270.	            accept: () => {
271.	                this.deleteCurrentHive();
272.	            }
273.	        })
274.	    }
275.	
276.	    private deleteCurrentHive() {
277.	        this.apiaryService.deleteHive(this.currentHive.id).subscribe({
278.	            next: () => { this.messageService.add({severity:'success',summary:'Success',detail:'You have successfully deleted hive'}); this.router.navigate(['/apiary','details']); },
279.	            error: () => { this.messageService.add({severity:'error',summary:'Error',detail:'Failed to delete hive'}); }
280.	        })
281.	    }
282.	}


Б.2 Програмний код розмітки компоненту для роботи з обладнанням

1.	div class="all-equipment">
2.	    <div class="container">
3.	        <div class="inner">
4.	            <h1>Equipment</h1>
5.	            <div>
6.	                <p-button icon="pi pi-plus" label="Register equipment" [style]="{marginBottom: '20px'}" (click)="openRegisterEquipment()"></p-button>
7.	
8.	                <div class="equipment-table" style="margin-bottom: 10px">
9.	                    <p-table [value]="equipments" [tableStyle]="{ 'min-width': '50rem' }" [paginator]="true" [rows]="5" [rowsPerPageOptions]="[5, 10]">
10.	                        <ng-template pTemplate="header">
11.	                            <tr>
12.	                                <th>Id</th>
13.	                                <th pSortableColumn="equipmentName">Equipment type <p-sortIcon field="equipmentName"></p-sortIcon></th>
14.	                                <th>Serial data</th>
15.	                                <th></th>
16.	                            </tr>
17.	                        </ng-template>
18.	                        <ng-template pTemplate="body" let-equipment>
19.	                            <tr>
20.	                                <td>{{ equipment.id }}</td>
21.	                                <td>{{ equipment.equipmentName }}</td>
22.	                                <td>{{ equipment.serialNumber }}</td>
23.	                                <td style="padding: 0px">
24.	                                    <p-button severity="danger" (click)="deleteEquipment(equipment)">{{ 'general.delete' | translate }}</p-button>
25.	                                </td>
26.	                            </tr>
27.	                        </ng-template>
28.	                    </p-table>
29.	                </div>
30.	            </div>
31.	        </div>
32.	    </div>
33.	</div>


Б.3 Програмний код сервісу для локалізації

1.	import { Injectable } from '@angular/core';
2.	import { TranslateService } from '@ngx-translate/core';
3.	import { environment } from '../environments/environment';
4.	
5.	@Injectable({
6.	    providedIn: 'root'
7.	})
8.	export class LocalizationService {
9.	    
10.	    formats = [
11.	        {
12.	            fullLang: "Ukraininan (31.01.2000)",
13.	            lang: "ua",
14.	            value: "dd.MM.yyyy"
15.	        },
16.	        {
17.	            fullLang: "USA (01-31-2000)",
18.	            lang: "usa",
19.	            value: "MM-dd-yyyy"
20.	        },
21.	        {
22.	            fullLang: "UK (31/01/2000)",
23.	            lang: "uk",
24.	            value: "dd/MM/yyyy"
25.	        }
26.	    ];
27.	
28.	    languages = [
29.	        {
30.	            label: "English",
31.	            value: "en"
32.	        },
33.	        {
34.	            label: "Ukraininan",
35.	            value: 'uk'
36.	        }
37.	    ]
38.	
39.	    timeZones = [
40.	        { label: "UTC-11", value: -11, },
41.	        { label: "UTC-10", value: -10, },
42.	        { label: "UTC-9", value: -9, },
43.	        { label: "UTC-8", value: -8, },
44.	        { label: "UTC-7", value: -7, },
45.	        { label: "UTC-6", value: -6, },
46.	        { label: "UTC-5", value: -5, },
47.	        { label: "UTC-4", value: -4, },
48.	        { label: "UTC-3", value: -3, },
49.	        { label: "UTC-2", value: -2, },
50.	        { label: "UTC-1", value: -1, },
51.	        { label: "UTC",   value:  0, },
52.	        { label: "UTC+1", value:  1, },
53.	        { label: "UTC+2", value:  2, },
54.	        { label: "UTC+3", value:  3, },
55.	        { label: "UTC+4", value:  4, },
56.	        { label: "UTC+5", value:  5, },
57.	        { label: "UTC+6", value:  6, },
58.	        { label: "UTC+7", value:  7, },
59.	        { label: "UTC+8", value:  8, },
60.	        { label: "UTC+9", value:  9, },
61.	        { label: "UTC+10", value: 10, },
62.	        { label: "UTC+11", value: 11, },
63.	        { label: "UTC+12", value: 12, },
64.	        { label: "UTC+13", value: 13, },
65.	        { label: "UTC+14", value: 14, },
66.	    ]
67.	
68.	    timeFormats = [
69.	        {
70.	            label: "12-hour (11:05 PM)",
71.	            value: "12",
72.	            format: "hh:mm a"
73.	        },
74.	        {
75.	            label: "24-hour (23:05)",
76.	            value: "24",
77.	            format: "HH:mm"
78.	        }
79.	    ]
80.	
81.	    currencies = ["$", "₴", "€", "£", "¥"]
82.	
83.	    constructor(private translateService: TranslateService)
84.	    {}
85.	
86.	    setLanguage(lang: string) {
87.	        this.translateService.use(lang);
88.	        localStorage.setItem("language", lang)
89.	    }
90.	
91.	    setDefaultLanguage() {
92.	        this.translateService.use(environment.defaultLocale)
93.	        localStorage.setItem("language", environment.defaultLocale)
94.	    }
95.	
96.	    setCurrentDataFormat(type: string) {
97.	        localStorage.setItem("dataformat", type);
98.	    }
99.	
100.	    setCurrentTimeZone(timezone: number) {
101.	        localStorage.setItem("timezone", timezone.toString());
102.	    }
103.	
104.	    setCurrentTimeFormat(timeformat: string) {
105.	        localStorage.setItem("timeformat", timeformat);
106.	    }
107.	
108.	    getCurrentLanguage() : string {
109.	        var result : string | null = localStorage.getItem("language");
110.	        if (result == null) {
111.	            return environment.defaultLocale;
112.	        }
113.	        return result;
114.	    }
115.	
116.	    getCurrentDataFormatType() : string {
117.	        var result = localStorage.getItem("dataformat");
118.	        if(result == null) {
119.	            return environment.defaultDateFormat;
120.	        }
121.	        return result;
122.	    }
123.	    
124.	    getCurrentDataFormat() {
125.	        var result = this.getCurrentDataFormatType();
126.	        const format = this.formats.find(item => item.lang == result);
127.	        return format
128.	    }
129.	
130.	    getCurrentTimeZone() : number {
131.	        var result = localStorage.getItem("timezone");
132.	        if(result == null)
133.	            return environment.defaultTimeZone;
134.	        return parseInt(result);
135.	    }
136.	
137.	    getCurrentTimeFormatType() : string {
138.	        var result = localStorage.getItem("timeformat");
139.	        if(result == null) {
140.	            return environment.defaultTimeFormat;
141.	        }
142.	        return result;
143.	    }
144.	
145.	    getCurrentTimeFormat() {
146.	        var result = this.getCurrentTimeFormatType();
147.	        const format = this.timeFormats.find(item => item.value == result);
148.	        return format
149.	    }
150.	
151.	    getCorrectLocalizedDateFormat() {
152.	        return this.getCurrentDataFormat()?.value + " "
153.	            + this.getCurrentTimeFormat()?.format;
154.	    }
155.	
156.	    getCorrectLocalizedDate(utcDate: Date | null | undefined) {
157.	        if(utcDate == null || utcDate == undefined) {
158.	            return null;
159.	        }
160.	
161.	        var newDate = new Date(utcDate);
162.	        newDate.setHours(newDate.getHours() + this.getCurrentTimeZone());
163.	        return newDate;
164.	    }
165.	}
 
ДОДАТОК В
Фрагменти коду програмного забезпечення для розумних пристроїв
В.1 Програмний код основного файлу для роботи вулику

1.	#include <WiFi.h>
2.	#include <HX711.h>
3.	#include <DHTesp.h>
4.	#include <SD.h>
5.	#include "sensor_send_service.h"
6.	#include "agregated_sensor_data_service.h"
7.	#include "config_manager.h"
8.	#include "config_structure.h"
9.	#include "time_util.h"
10.	
11.	const char* ssid = "Wokwi-GUEST";
12.	const char* password = "";
13.	const char* configFile = "/config.json";
14.	
15.	const float BETA = 3950;
16.	const float WEIGHT_COEF = 419;
17.	
18.	const int CS_PIN = 5;
19.	const int DHT_PIN = 22;
20.	const int HX_DT_PIN = 4;
21.	const int HX_SCK_PIN = 0;
22.	const int BUTTON_PIN = 25;
23.	const int LED_PIN = 32;
24.	const int SETUP_BUTTON_PIN = 26;
25.	
26.	DHTesp dhtSensor;
27.	HX711 loadSensor;
28.	int button_state;
29.	int setup_button_state;
30.	int led_state = LOW;
31.	
32.	ConfigManager configManager;
33.	ServerInteractionService serverInteractionService;
34.	AgregatedSensorDataService agregatedSensorDataService(5);
35.	
36.	void setupWiFi() {
37.	  Serial.println("Connecting to wifi...");
38.	  while (WiFi.status() != WL_CONNECTED) {
39.	    WiFi.begin(ssid, password, 6);
40.	    delay(1000);
41.	    Serial.println("Retry..");
42.	  }
43.	
44.	  Serial.println("Connected to WiFi");
45.	}
46.	
47.	void syncTime() {
48.	  configTime(0, 0, "pool.ntp.org", "time.nist.gov");
49.	  Serial.print("Waiting for time");
50.	  time_t now = time(nullptr);
51.	  while (now < 8 * 3600 * 2) {
52.	      Serial.print(".");
53.	      delay(1000);
54.	      now = time(nullptr);
55.	  }
56.	
57.	  Serial.println();
58.	  Serial.println("Time synchronized");
59.	}
60.	
61.	void setup() {
62.	  Serial.begin(115200);
63.	  Serial.println("Esp32 started.");
64.	  
65.	  // WiFi setup 
66.	  setupWiFi();
67.	
68.	  // DHT setup (humidity and temp)
69.	  dhtSensor.setup(DHT_PIN, DHTesp::DHT22);
70.	  Serial.println("DHT setup completed");
71.	
72.	  // HX711/710 setup (weight/load sensor)
73.	  loadSensor.begin(HX_DT_PIN, HX_SCK_PIN);
74.	  //loadSensor.set_scale(2280.f);
75.	  loadSensor.tare();
76.	  Serial.println("HX setup completed");
77.	
78.	  // Button and LED setup
79.	  pinMode(BUTTON_PIN, INPUT_PULLUP);
80.	  pinMode(LED_PIN, OUTPUT);
81.	  pinMode(SETUP_BUTTON_PIN, INPUT_PULLUP);
82.	
83.	  // Config initilizing
84.	  if (!SD.begin(CS_PIN)) {
85.	    Serial.println("Card initialization failed!");
86.	    while (true);
87.	  }
88.	  configManager.loadFromFile(configFile);
89.	
90.	  Config config = configManager.getConfig();
91.	  String serverConfigUrl = config.serverUrl + "/api/Apiary/hive/configuration/" + config.hiveId;
92.	  bool serverConfigResult = configManager.loadFromServer(serverConfigUrl.c_str());
93.	  if(serverConfigResult == false) {
94.	    Serial.println("An error occurred while retrieving the configuration from the server. Restart the application and try again");
95.	    while(true) {
96.	      
97.	    }
98.	  } 
99.	
100.	  configManager.printCurrentConfig();
101.	
102.	  serverInteractionService.initialize(config.serverUrl);
103.	  Serial.println("Server url initialized as " + config.serverUrl);
104.	
105.	  // Time configuration
106.	  syncTime();
107.	  Serial.println("Initialization done.");
108.	}
109.	
110.	void loop() {
111.	  // weight calibration
112.	  button_state = digitalRead(BUTTON_PIN);
113.	  if (button_state == LOW) {
114.	    Serial.println("Weight calibration");
115.	    loadSensor.tare();
116.	    led_state = HIGH;
117.	    Serial.println("Weight calibration completed");
118.	  }
119.	  else {
120.	    led_state = LOW;
121.	  }
122.	
123.	  // setup from server
124.	  setup_button_state = digitalRead(SETUP_BUTTON_PIN);
125.	  if (setup_button_state == LOW) {
126.	    Serial.println("Getting setup Data from server");
127.	  
128.	    Config config = configManager.getConfig();
129.	    String serverConfigUrl = config.serverUrl + "/api/Apiary/hive/configuration/" + config.hiveId;
130.	    bool serverConfigResult = configManager.loadFromServer(serverConfigUrl.c_str());
131.	    if(serverConfigResult == false) {
132.	      Serial.println("An error occurred while retrieving the configuration from the server. Restart the application and try again");
133.	      while(true) {
134.	        
135.	      }
136.	    } 
137.	    configManager.printCurrentConfig();
138.	
139.	  }
140.	
141.	  digitalWrite(LED_PIN, led_state);
142.	
143.	  TempAndHumidity data = dhtSensor.getTempAndHumidity();
144.	  float weightData = loadSensor.get_units() / WEIGHT_COEF;
145.	  String currentTime = getUtcTime();
146.	  Config config = configManager.getConfig();
147.	  Serial.print("--- ");
148.	  Serial.print(currentTime);
149.	  Serial.println(" ---");
150.	  Serial.println("Temp: " + String(data.temperature, 2) + "°C");
151.	  Serial.println("Humidity: " + String(data.humidity, 1) + "%");
152.	  Serial.println("Weight: " + String(weightData) + "kg");
153.	
154.	  bool tempToSend = agregatedSensorDataService.addTempReading(data.temperature);
155.	  if(tempToSend) {
156.	    float agregatedTemp = agregatedSensorDataService.getAverageTemp();
157.	    agregatedSensorDataService.compareToCritical("temp", config.criticalTempHigh, config.criticalTempLow, agregatedTemp);
158.	    serverInteractionService.sendSensorData(agregatedTemp, config.tempSensorId, config.hubId, currentTime);
159.	    agregatedSensorDataService.resetTemp();
160.	  }
161.	
162.	  bool humidityToSend = agregatedSensorDataService.addHumidityReading(data.humidity);
163.	  if(humidityToSend) {
164.	    float agregatedHumidity = agregatedSensorDataService.getAverageHumidity();
165.	    agregatedSensorDataService.compareToCritical("humidity", config.criticalHumidityHigh, config.criticalHumidityLow, agregatedHumidity);
166.	    serverInteractionService.sendSensorData(agregatedHumidity, config.humiditySensorId, config.hubId, currentTime);
167.	    agregatedSensorDataService.resetHumidity();
168.	  }
169.	
170.	  bool weightToSend = agregatedSensorDataService.addWeightReading(weightData);
171.	  if(weightToSend) {
172.	    float agregatedWeight = agregatedSensorDataService.getAverageWeight();
173.	    serverInteractionService.sendSensorData(agregatedWeight, config.weightSensorId, config.hubId, currentTime);
174.	    agregatedSensorDataService.resetWeight();
175.	  }
176.	  delay(2500);
177.	}


В.2 Програмний код сервісу для надсилання даних з датчиків на сервер

1.	#include "sensor_send_service.h"
2.	
3.	void ServerInteractionService::initialize(const String& serverUrl) {
4.	  serverUrl_ = serverUrl;
5.	}
6.	
7.	bool ServerInteractionService::sendSensorData(float sensorValue, const String& sensorId, const String& hubId, const String& timestamp) {
8.	    if (WiFi.status() == WL_CONNECTED) {
9.	        HTTPClient http;
10.	        String fullUrl = String(serverUrl_) + "/api/Sensor/readings/hub/" + hubId;
11.	        http.begin(fullUrl);
12.	        http.addHeader("Content-Type", "application/json");
13.	
14.	        String payload = "[{";
15.	        payload += "\"value\": " + String(sensorValue) + ",";
16.	        payload += "\"sensorId\": \"" + sensorId + "\",";
17.	        payload += "\"readingDate\": \"" + timestamp + "\"";
18.	        payload += "}]";
19.	        Serial.println(fullUrl);
20.	        Serial.println(payload);
21.	        int httpResponseCode = http.POST(payload);
22.	        bool success = httpResponseCode > 0 && httpResponseCode < 300;
23.	
24.	        if (success) {
25.	            Serial.println("Data sent successfully: " + String(httpResponseCode));
26.	        } else {
27.	            Serial.println("Error sending data: " + String(httpResponseCode));
28.	        }
29.	        
30.	        http.end();
31.	        return success;
32.	    } else {
33.	        Serial.println("Wi-Fi not connected");
34.	        return false;
35.	    }
36.	}
37.	

В.3 Програмний код виконуваного файлу менеджеру конфігурації


1.	#include <ArduinoJson.h>
2.	#include <FS.h>
3.	#include <WiFi.h>
4.	#include <SD.h>
5.	#include <HTTPClient.h>
6.	#include "config_manager.h"
7.	
8.	bool ConfigManager::loadFromFile(const char* filename) {
9.	    File file = SD.open(filename, FILE_READ);
10.	    if (!file) {
11.	        Serial.print("Failed to open config file; filename: ");
12.	        Serial.println(filename);
13.	        return false;
14.	    }
15.	
16.	    size_t size = file.size();
17.	    std::unique_ptr<char[]> buf(new char[size]);
18.	
19.	    file.readBytes(buf.get(), size);
20.	    file.close();
21.	
22.	    StaticJsonDocument<512> doc;
23.	    DeserializationError error = deserializeJson(doc, buf.get());
24.	
25.	    if (error) {
26.	        Serial.print("deserializeJson() failed: ");
27.	        Serial.println(error.c_str());
28.	        return false;
29.	    }
30.	
31.	    config_.criticalHumidityHigh = doc["criticalHumidityHigh"].as<float>();
32.	    config_.criticalHumidityLow = doc["criticalHumidityLow"].as<float>();
33.	    config_.criticalTempHigh = doc["criticalTempHigh"].as<float>();
34.	    config_.criticalTempLow = doc["criticalTempLow"].as<float>();
35.	    config_.humiditySensorId = doc["humiditySensorId"].as<String>();
36.	    config_.weightSensorId = doc["weightSensorId"].as<String>();
37.	    config_.tempSensorId = doc["tempSensorId"].as<String>();
38.	    config_.hiveId = doc["hiveId"].as<String>();
39.	    config_.serverUrl = doc["serverUrl"].as<String>();
40.	
41.	    Serial.println("Config loaded from file");
42.	    return true;
43.	}
44.	
45.	bool ConfigManager::loadFromServer(const char* serverUrl) {
46.	    if (WiFi.status() != WL_CONNECTED) {
47.	        Serial.println("WiFi not connected");
48.	        return false;
49.	    }
50.	
51.	    HTTPClient http;
52.	    Serial.print("Getting configuration from ");
53.	    Serial.println(serverUrl);
54.	    http.begin(serverUrl);
55.	    int httpResponseCode = http.GET();
56.	
57.	    if (httpResponseCode > 0) {
58.	        String payload = http.getString();
59.	        Serial.println("Received payload: " + payload);
60.	
61.	        StaticJsonDocument<512> doc;
62.	        DeserializationError error = deserializeJson(doc, payload);
63.	
64.	        if (error) {
65.	            Serial.print("deserializeJson() failed: ");
66.	            Serial.println(error.c_str());
67.	            return false;
68.	        }
69.	
70.	        if(httpResponseCode == 404) {
71.	          Serial.println("Error while configuring");
72.	          Serial.println(doc["error"].as<String>());
73.	          return false;
74.	        }
75.	
76.	        config_.hiveId = doc["hiveId"].as<String>();
77.	        config_.humiditySensorId = doc["humiditySensorId"].as<String>();
78.	        config_.weightSensorId = doc["weightSensorId"].as<String>();
79.	        config_.tempSensorId = doc["tempSensorId"].as<String>();
80.	        config_.hubId = doc["hubId"].as<String>();
81.	        config_.criticalHumidityHigh = doc["criticalHumidityHigh"].as<float>();
82.	        config_.criticalHumidityLow = doc["criticalHumidityLow"].as<float>();
83.	        config_.criticalTempHigh = doc["criticalTempHigh"].as<float>();
84.	        config_.criticalTempLow = doc["criticalTempLow"].as<float>();
85.	        return true;
86.	    } else {
87.	        Serial.print("Error on HTTP request: ");
88.	        Serial.println(httpResponseCode);
89.	        return false;
90.	    }
91.	
92.	    http.end();
93.	}
94.	
95.	const Config& ConfigManager::getConfig() const {
96.	    return config_;
97.	}
98.	
99.	void ConfigManager::printCurrentConfig() {
100.	  Serial.println("Current configuration:");
101.	  Serial.println("> Hive Id: " + config_.hiveId);
102.	  Serial.println("> Humidity Sensor Id: " + config_.humiditySensorId);
103.	  Serial.println("> Weight Sensor Id: " + config_.weightSensorId);
104.	  Serial.println("> Temperature Sensor Id: " + config_.tempSensorId);
105.	  Serial.println("> Hub Id: " + config_.hubId);
106.	  Serial.println("> Critical Humidity High: " + String(config_.criticalHumidityHigh));
107.	  Serial.println("> Critical Humidity Low: " + String(config_.criticalHumidityLow));
108.	  Serial.println("> Critical Temperature High: " + String(config_.criticalTempHigh));
109.	  Serial.println("> Critical Temperature Low: " + String(config_.criticalTempLow));
110.	  Serial.println("> Server URL: " + config_.serverUrl);
111.	}
 
ДОДАТОК Г
Фрагменти коду мобільного застосунку
Г.1 Програмний код розмітки сторінки з деталями пасіки


1	<?xml version="1.0" encoding="utf-8" ?>
2	<ContentPage xmlns="http://xamarin.com/schemas/2014/forms"
3	             xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
4	             x:Class="ApexiBeeMobile.Views.ApiaryDetailsPage">
5	    <ContentPage.Content>
6	        <StackLayout>
7	
8	            <ListView HasUnevenRows="True" x:Name="apiariesList" ItemsSource="{Binding Hives}">
9	                <ListView.ItemTemplate>
10	                    <DataTemplate>
11	                        <ViewCell>
12	                            <ViewCell.View>
13	                                <Frame Padding="10" Margin="5" BorderColor="LightGray" CornerRadius="10" HasShadow="True">
14	                                    <StackLayout Orientation="Vertical" Spacing="5">
15	                                        <Label Text="Hive" FontSize="Medium" FontAttributes="Bold" TextColor="DarkBlue" />
16	                                        <Label Text="{Binding Name}" FontSize="Medium" FontAttributes="Bold" TextColor="DarkBlue" />
17	                                        <Grid>
18	                                            <Grid.RowDefinitions>
19	                                                <RowDefinition Height="Auto" />
20	                                                <RowDefinition Height="Auto" />
21	                                            </Grid.RowDefinitions>
22	                                            <Grid.ColumnDefinitions>
23	                                                <ColumnDefinition Width="Auto" />
24	                                                <ColumnDefinition Width="*" />
25	                                            </Grid.ColumnDefinitions>
26	                                            <Label Grid.Row="0" Grid.Column="0" Text="ID:" FontAttributes="Bold" />
27	                                            <Label Grid.Row="0" Grid.Column="1" Text="{Binding Id}" LineBreakMode="TailTruncation" />
28	
29	                                            <Label Grid.Row="1" Grid.Column="0" Text="Description:" FontAttributes="Bold" />
30	                                            <Label Grid.Row="1" Grid.Column="1" Text="{Binding Description}" LineBreakMode="WordWrap" />
31	                                        </Grid>
32	
33	                                        <!-- Вивід датчиків -->
34	                                        <StackLayout Orientation="Vertical" Spacing="3">
35	                                            <Label Text="Sensors" FontSize="Small" FontAttributes="Bold" />
36	                                            <StackLayout Orientation="Vertical" Spacing="1">
37	                                                <Label Text="{Binding Sensors}" FontSize="Small" />
38	                                                <!-- Если Sensors это коллекция, покажем каждый датчик в отдельной Label -->
39	                                                <StackLayout BindableLayout.ItemsSource="{Binding Sensors}" Orientation="Vertical">
40	                                                    <BindableLayout.ItemTemplate>
41	                                                        <DataTemplate>
42	                                                            <Label Text="{Binding Value}" FontSize="Small" />
43	                                                        </DataTemplate>
44	                                                    </BindableLayout.ItemTemplate>
45	                                                </StackLayout>
46	                                            </StackLayout>
47	                                        </StackLayout>
48	
49	                                    </StackLayout>
50	                                </Frame>
51	                            </ViewCell.View>
52	                        </ViewCell>
53	                    </DataTemplate>
54	                </ListView.ItemTemplate>
55	            </ListView>
56	        </StackLayout>
57	    </ContentPage.Content>
58	</ContentPage>


Г.2 Програмний код відображення моделі пасіки


1	public class ApiariesViewModel
2	    {
3	        public ObservableCollection<Apiary> Apiaries { get; set; }
4	        private Apiary selectedApiary { get; set; }
5	
6	        private IApiaryService _apiaryService = DependencyService.Get<IApiaryService>();
7	
8	        public ApiariesViewModel()
9	        {
10	            Apiaries = new ObservableCollection<Apiary>();
11	            this._apiaryService = DependencyService.Get<IApiaryService>();
12	        }
13	
14	        public async Task GetApiaries()
15	        {
16	            try
17	            {
18	                IEnumerable<Apiary> apiaries = await this._apiaryService.GetUserApiaries();
19	                Apiaries.Clear();
20	
21	                // Adding loaded from server data to obserable collection
22	                foreach (var apiary in apiaries)
23	                    Apiaries.Add(apiary);
24	            }
25	            catch
26	            {
27	                Debug.WriteLine("Failed to load apiaries list");
28	                Apiaries = null;
29	            }
30	        }
31	
32	        public Apiary SelectedApiary
33	        {
34	            get { return selectedApiary; }
35	            set
36	            {
37	                if (selectedApiary != value)
38	                {
39	                    Apiary tempApiary = new Apiary()
40	                    {
41	                        Id = value.Id,
42	                        Name = value.Name,
43	                        CreationDate = value.CreationDate,
44	                        Description = value.Description,
45	                        BeekeeperId = value.BeekeeperId
46	                    };
47	                    selectedApiary = null;
48	                    Shell.Current.GoToAsync($"{nameof(ApiaryDetailsPage)}?Id={tempApiary.Id}");
49	                }
50	            }
51	        }
52	    }

Г.3 Програмний код сервісу для роботи з пасікою


1	public class ApiaryService : ServiceBase, IApiaryService
2	{
3	    private readonly IAuthService _authService;
4	
5	    readonly string apiUrl = Preferences.Get("ApiUrl", "") + "/api/Apiary";
6	
7	    public ApiaryService()
8	    {
9	        this._authService = DependencyService.Get<IAuthService>();
10	    }
11	
12	    public async Task<IEnumerable<Hive>> GetApiaryHives(Guid apiaryId)
13	    {
14	        HttpClient client = GetClient();
15	        string result = await client.GetStringAsync($"{apiUrl}/hives/{apiaryId}");
16	        return JsonSerializer.Deserialize<IEnumerable<Hive>>(result, options);
17	    }
18	
19	    public async Task<IEnumerable<Apiary>> GetUserApiaries()
20	    {
21	        Guid userAccountId = this._authService.GetUserAccountIdFromToken();
22	
23	        HttpClient client = GetClient();
24	        string result = await client.GetStringAsync($"{apiUrl}/user/{userAccountId}");
25	        return JsonSerializer.Deserialize<IEnumerable<Apiary>>(result, options);
26	    }
27	}

